<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式物联网边缘计算服务设计与实现</title>
      <link href="/2020/05/22/ProjectEdge/%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%A9%E8%81%94%E7%BD%91%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/05/22/ProjectEdge/%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%A9%E8%81%94%E7%BD%91%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><h3 id="1-1-课题的研究背景和意义"><a href="#1-1-课题的研究背景和意义" class="headerlink" title="1.1 课题的研究背景和意义"></a>1.1 课题的研究背景和意义</h3><p>到2020年，全球联网的设备已超过200亿台，随着IPv6主干网建设和5G移动网络的部署，将有更多的物联网设备之间连接到互联网。云端需要处理越来越多的边缘端设备数据，同时边缘端设备的安全性也面临着不小的挑战。</p><p>无人驾驶汽车的传感器和摄像头，实时捕捉路况信息，每秒大约会产生1GB的数据，如果无人驾驶判断依赖于云服务，不能保证服务的随时可用性和稳定性，而且还会给服务器造成不少的带宽压力。所以无人驾驶汽车这类产品需要能自身进行计算而不依赖于互联网。再以智能家居为例，越来越多的家庭设备依赖于云计算平台来进行控制，一旦网络出现故障，即使家里仍然有电，设备也不能很好的控制了。现在市场上几乎所有的智能音箱产品，只要脱离了互联网运行，就是电子废品，不管问什么问题，甚至是问个时间，都只会回答“请先连接到网络”。</p><p>边缘计算架构是将每个边缘节点设备赋予自主计算能力，简单来讲就是在边缘物联网传感器网络中加入一个高级网关，这个网关负责对传感器数据分析或存储，将部分信息、结果信息或报警信息上报到云服务。比如道路上的摄像头，边缘网关节点通过机器学习训练好的识别模型对摄像头画面进行汽车违规分析，假如识别到了违规情况和违规的车牌号，网关则会将这条违规信息上报到服务器。</p><p>本课题将云端的分布式服务架构整合到边缘计算架构中，并引入DevOps开发模型。将云端技术应用到边缘物联网设备中。同时能在边缘端支持横向拓展、应用隔离、服务发现、负载均衡、滚动升级。</p><h3 id="1-2-国内外研究现状"><a href="#1-2-国内外研究现状" class="headerlink" title="1.2 国内外研究现状"></a>1.2 国内外研究现状</h3><h4 id="1-2-1-国内研究现状"><a href="#1-2-1-国内研究现状" class="headerlink" title="1.2.1 国内研究现状"></a>1.2.1 国内研究现状</h4><p>KubeEdge是华为在2018年开源的面向边缘环境容器管理平台，KubeEdge能够接入云端Kubernetes集群，使得边缘应用的管理可以跟云端应用的管理一样，采用Kubernetes API。KubeEdge是一个开源系统，将本机容器化应用程序业务流程和设备管理扩展到边缘的主机。它基于 Kubernetes 构建，为云和边缘之间的网络、应用程序部署和元数据同步提供核心基础设施支持。它还支持 MQTT，并允许开发人员在 Edge 上编写自定义逻辑并启用资源受限的设备通信。</p><p><img src="https://docs.kubeedge.io/en/latest/_images/kubeedge_arch.png" alt="KubeEdge架构"></p><p>KubeEdge分为云端节点和边缘节点，云端节点依赖于Kubernetes集群，云端节点实现了一套Kubernetes API，将边缘节点与Kubernetes集群整合到一起管理。目前KubuEdge还处于初级开发版本，很多Kubernetes的基本组件还不支持（如：Persistent Volume、Ingress、Secret），这也给集群管理产生了很多麻烦。</p><h4 id="1-2-2-国外研究现状"><a href="#1-2-2-国外研究现状" class="headerlink" title="1.2.2 国外研究现状"></a>1.2.2 国外研究现状</h4><p>K3S是Rancher出品的一个开源、简化、轻量Kubernetes，为物联网和边缘计算建立分布式的Kubernetes。支持ARM64和ARMv7架构，从很小的树莓派到AWS的a1.4xlarge 32GiB服务器都能运行。K3S只有一个不到40MB的可执行二进制文件，并且内置了容器引擎而不需要额外安装Docker，减少了安装、运行和更新Kubernetes集群所需的依赖性和步骤。</p><p><img src="https://github.com/zuozishi/ProjectEdgeDoc/raw/master/image/k3s.png" alt="K3S架构"></p><p>K3S移除了所有Beta版的API，与Kubernetes架构基本差别不大。master节点用了更轻便的SQLite代替了k8s的etcd数据库，边缘节点使用了内置的容器引擎来代替Docker CE引擎。还可以使用Flannel网络组件打通集群Pod之间的网络通讯。K3S除了可以在物联网边缘计算场景中使用，还可以在ARM服务器集群中运行分布式应用。</p><h3 id="1-3-本课题的研究内容及章节安排"><a href="#1-3-本课题的研究内容及章节安排" class="headerlink" title="1.3 本课题的研究内容及章节安排"></a>1.3 本课题的研究内容及章节安排</h3><h4 id="1-3-1-课题研究的内容"><a href="#1-3-1-课题研究的内容" class="headerlink" title="1.3.1 课题研究的内容"></a>1.3.1 课题研究的内容</h4><p>通过查阅大量现有的边缘计算资料和书籍，结合多年来对云计算技术的学习和了解以及分析现有分布式边缘计算架构的特点和缺陷，通过云端K8S集群+边缘端K3S+边缘服务发现+DevOps自动化部署，实现了一套易管理、易扩展、易部署的分布式物联网边缘计算架构。</p><p>首先将分布式物联网边缘计算架构分为云-边-端三层。云端包括完整的Kubernetes集群、Azure DevOps Agent服务、Rancher集群管理服务、NFS服务、K3S Server。边缘端作为物联网边缘网关运行K3S Agent，边缘端与云端共享Config Map、Secert、Persistent Volume，并集成DDNS以更好的支持IPv6网络访问，集成frpc以穿透IPv4 NAT网络进行直接访问。设备端可以通过端口扫描、UDP广播、DNS等方式扫描局域网内的边缘节点，当前网络如果不存在边缘节点，设备端也可以直接连接到云端工作。</p><p>NFS服务器作为Kubernetes的一个Persistent Volume用来保存跨集群节点使用的持久化数据（如：配置文件、用户上传的文件等），Rancher集群管理服务可以同时管理云端的Kubernetes集群和边缘端的k3s集群，同时给Azure DevOps提供应用部署接口API。DDNS服务通过阿里云DNS解析API将所有边缘节点的IPv4和IPv6地址解析在域名<code>&lt;边缘节点主机名&gt;.zuozishi.online</code>上。frpc服务将边缘节点需要远程访问和管理的端口通过frp服务穿透到公网服务器，这样就能突破IPv4 NAT网络直接访问到边缘节点，这是一种IPv4到IPv6的过渡解决方案。</p><p>所有的云端、边缘端、设备端代码托管在Github和Azure DevOps Repos平台上，当本地代码推送到在线仓库时，触发Azure Pipelines自动化编译、测试、部署事件，将应用镜像推送到阿里云镜像库，通过应用部署配置文件将应用部署到云端、边缘端或设备端。云端、边缘端或设备端会根据配置文件从阿里云镜像库拉取镜像并运行。</p><p>云端、边缘端示例应用为网络音乐播放服务。网络音乐播放服务使用ASP .Net Core 3.1框架，实现用户使用酷狗账号登录、用户播放列表、音乐搜索、获取音乐歌词和URL等API接口，提供一个简单的Web访问界面，通过SignalR协议与设备端连接并通信。 设备端通过UDP广播包查询本地边缘节点，然后使用SignalR协议连接，实时报告音乐播放情况并接收控制指令。手机APP也在这个应用场景中作为设备端，一样通过UDP广播包查询本地边缘节点然后连接并通信。如果本地不存在边缘节点，音乐播放设备和手机APP将直接连到云端部署的应用进行工作。</p><h4 id="1-3-2-论文章节安排"><a href="#1-3-2-论文章节安排" class="headerlink" title="1.3.2 论文章节安排"></a>1.3.2 论文章节安排</h4><p>本文章节安排如下：</p><p>第一章、引言。介绍分布式边缘计算的背景和意义，介绍国内外分布式边缘计算架构的发展和研究现状，介绍论文的主要研究内容和章节安排。</p><p>第二章、分布式边缘计算相关技术。介绍边缘计算和分布式的概念和特点，介绍虚拟化和容器技术的发展。</p><p>第三章、云端架构的分析与设计。阐述了分布式物联网边缘计算架构中服务端服务器的规划和重要服务的部署。</p><p>第四章、边缘端架构的分析与设计。阐述了分布式物联网边缘计算架构中边缘端的配置规划和重要服务。</p><p>第五章、应用的设计与实现。以音乐播放服务为例说明边缘网关和边缘设备以及云端的实际应用层设计。</p><p>第六章、系统关键代码及配置。列出了从云端、边缘网关到设备三方的关键代码和配置文件。</p><p>第七章、系统测试及改进。对云端、边缘网关和设备进行服务和功能测试，并针对现有不足做出改进方案。</p><h2 id="2-分布式边缘计算相关技术"><a href="#2-分布式边缘计算相关技术" class="headerlink" title="2 分布式边缘计算相关技术"></a>2 分布式边缘计算相关技术</h2><h3 id="2-1-边缘计算的概念和特点"><a href="#2-1-边缘计算的概念和特点" class="headerlink" title="2.1 边缘计算的概念和特点"></a>2.1 边缘计算的概念和特点</h3><p>边缘计算采用一种分散式运算的架构，将之前由网络中心节点处理的应用程序、数据资料与服务的运算交由网络逻辑上的边缘节点处理。边缘计算将大型服务进行分解，切割成更小和更容易管理的部分，把原本完全由中心节点处理的大型服务分散到边缘节点。而边缘节点更接近用户终端装置，这一特点显著提高了数据处理速度与传送速度，进一步降低时延。</p><p>边缘计算作为云计算模型的扩展和延伸，直面目前集中式云计算模型的发展短板，具有缓解网络带宽压力、增强服务响应能力、保护隐私数据等特征。在智慧城市、智能制造、智能交通、智能家居、智能零售以及视频监控系统等领域，边缘计算都在扮演着先进的改革者形象，推动传统的“云到端”演进为“云-边-端”的新型计算架构。</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=752513542,1323126138&fm=26&gp=0.jpg" alt="边缘计算架构"></p><h3 id="2-2-虚拟化和容器技术"><a href="#2-2-虚拟化和容器技术" class="headerlink" title="2.2 虚拟化和容器技术"></a>2.2 虚拟化和容器技术</h3><p>虚拟化是云计算的重要技术，可以将物理资源弹性地分配给客户。主机虚拟化的思想可以追溯到 IBM 机器的逻辑分区，即把一台 IBM 机器划分成若干台逻辑的服务器，每台逻辑服务器拥有独占的计算资源（CPU、内存、硬盘、网卡），可以单独安装和运行操作系统。IBM 机器价格昂贵，相对于当时的计算任务来说，机器的计算能力太过强大，所以需要划分为更小的计算单元。</p><p>后来随着个人计算机处理能力的不断发展，1998 年 VMware 公司成立，这家公司专注于机器虚拟化的软件解决方案。也就是说，对于不支持逻辑分区的计算机，可以直接通过安装 VMware 虚拟化软件来模拟更多的虚拟机，然后再在这些虚拟机里安装操作系统和应用软件，可以给虚拟机灵活配置内存、CPU、硬盘和网卡等资源。</p><p><img src="https://www.docker.com/sites/default/files/d8/2018-11/container-vm-whatcontainer_2.png" alt="虚拟化技术"></p><p>但是在每台虚拟机里都要安装和运行操作系统的做法，仍然浪费了很多计算资源。为此，有公司专门推出了应用软件容器产品，即在操作系统层上创建一个个容器，这些容器共享下层的操作系统内核和硬件资源，但是每个容器可单独限制 CPU、内存、硬盘和网络带宽容量，并且拥有单独的 IP 地址和操作系统管理员账户，可以关闭和重启。与虚拟机最大的不同是，容器里不用再安装操作系统，因此浪费的计算资源也就大大减少了，这样同样一台计算机就可以服务于更多的租户。</p><p><img src="https://www.docker.com/sites/default/files/d8/2018-11/docker-containerized-appliction-blue-border_2.png" alt="容器技术"></p><h3 id="2-3-分布式架构和Kubernetes"><a href="#2-3-分布式架构和Kubernetes" class="headerlink" title="2.3 分布式架构和Kubernetes"></a>2.3 分布式架构和Kubernetes</h3><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p><p>在3G移动网络发展初期，随着上网人数的飙升和人均上网带宽增加，单服务器应用已经不能满足需求，云计算开始发展,企业也开始将一个应用的不同组件放在多个服务器上来均衡流量和提高可用性。例如像淘宝这类的网站，要解决的重点问题就是海量商品搜索、下单、支付等问题; 像腾讯这类的网站，要解决的是数亿级别用户的实时消息传输;而像百度这类的公司所要解决的又是海量数据的搜索。每一个种类的业务都有自己不同的系统架构。</p><p><img src="https://images2018.cnblogs.com/blog/894443/201806/894443-20180625095828062-769155408.png" alt="分布式架构应用"></p><p>Kubernetes 是用于自动部署，扩展和管理容器化应用程序的开源系统。它将组成应用程序的容器组合成逻辑单元，以便于管理和服务发现。Kubernetes 源自Google 15 年生产环境的运维经验，同时凝聚了社区的最佳创意和实践。Google 每周运行数十亿个容器，Kubernetes 基于与之相同的原则来设计，能够在不扩张运维团队的情况下进行规模扩展。Kubernetes 是开源系统，可以自由地部署在企业内部，私有云、混合云或公有云。</p><p>Kubernetes是一个全新的的分布式架构领先方案，它基于容器技术，目的是实现资源管理的自动化，以及多个数据中心的资源利用率的最大化。通常，我们会把Kubernetes看作Docker的上层架构，就好像Java与J2EE的关系一样：J2EE是以Java为基础的企业级软件架构，Kubernetes则以Docker为基础打造了一个云计算时代的全新分布式系统架构。</p><blockquote><p>Kubernetes并不是依赖于Docker，也可以支持其他的容器引擎，如：Rocket、lxd 、rkt。</p></blockquote><h2 id="3-云端架构的分析与设计"><a href="#3-云端架构的分析与设计" class="headerlink" title="3 云端架构的分析与设计"></a>3 云端架构的分析与设计</h2><h3 id="3-1-云端基础架构配置和规划"><a href="#3-1-云端基础架构配置和规划" class="headerlink" title="3.1 云端基础架构配置和规划"></a>3.1 云端基础架构配置和规划</h3><p>云端服务器使用了五台阿里云的ECS（Elastic Compute Service）学生免费版入门级服务器，详细配置如下：</p><ul><li><p>CPU：2核</p></li><li><p>内存：4GiB</p></li><li><p>操作系统：CentOS 7.7 64位</p></li><li><p>独立公网IP</p></li><li><p>公网带宽：1Mbps</p></li><li><p>系统盘：40GiB (2120 IOPS)</p></li><li><p>地域：阿里云-华北2（北京）</p></li></ul><blockquote><p>注：由于个人能力，实验集群只在阿里云北京区域中搭建，如果跨不同地区搭建集群，则可以实现多地负载均衡，不过需要收取跨地区通信的流量费。</p></blockquote><p>由于五台机器属于不同的阿里云账号下，所以这五台机器不属于一个局域网，需要先在阿里云平台配置跨账号的云企业网，配置云企业网的实质则是配置这五个机器内网网段的路由表，配置完成后则认为这五台机器通过这个路由表进行跨网段通信。</p><p><img src="https://github.com/zuozishi/ProjectEdgeDoc/raw/master/image/%E4%BA%91%E4%BC%81%E4%B8%9A%E7%BD%91.png" alt="云企业网"></p><p>其中一台机器作为master节点，两台机器作为node工作节点，一台服务器用来部署NFS文件共享服务、Azure Pipelines Agent和Rancher集群管理服务，一台作为k3s的master节点。</p><table><thead><tr><th>主机名</th><th>内网IP</th><th>外网IP</th><th>角色</th></tr></thead><tbody><tr><td>Zuozishi-Master</td><td>172.17.151.242</td><td>39.107.139.105</td><td>k8s master</td></tr><tr><td>Zuozishi-Slave1</td><td>172.17.57.231</td><td>39.97.161.176</td><td>k8s工作节点</td></tr><tr><td>Zuozishi-Slave2</td><td>172.17.77.128</td><td>47.93.236.68</td><td>k8s工作节点</td></tr><tr><td>Aliyun-YXM</td><td>172.17.196.228</td><td>39.97.114.49</td><td>k3s master、frps服务</td></tr><tr><td>Aliyun-TXR</td><td>172.17.81.0</td><td>47.94.90.203</td><td>NFS服务、集群管理者</td></tr></tbody></table><p>考虑到外部连接集群和应用的安全性，尽量使用了HTTPS协议，所以先要为主机申请SSL证书，本项目使用在阿里云申请的一年有效期的免费SSL证书。</p><p><img src="https://github.com/zuozishi/ProjectEdgeDoc/raw/master/image/ssl.png" alt="SSL证书申请"></p><h3 id="3-2-Kubernetes集群配置"><a href="#3-2-Kubernetes集群配置" class="headerlink" title="3.2 Kubernetes集群配置"></a>3.2 Kubernetes集群配置</h3><pre class="mermaid">graph TB    subgraph 阿里云    A[k8s主节点] --> B[k8s工作节点1]    A[k8s主节点] --> C[k8s工作节点2]    end</pre><p>修改需要安装Kubernetes所有主机的Hosts：</p><pre><code class="bash">echo &gt; /etc/hosts &lt; EOF::1 localhost127.0.0.1 localhost172.17.57.231   Zuozishi-Slave1172.17.77.128   Zuozishi-Slave2172.17.196.228  Zuozishi-Slave3172.17.81.0     Aliyun-TXR      Zuozishi-NFS172.17.151.242  Zuozishi-Master172.17.151.242  Zuozishi-Master Zuozishi-MasterEOF</code></pre><p>在master节点运行自己编写的一键配置/安装脚本，脚本大概过程如下：</p><ol><li><p>关闭防火墙</p></li><li><p>配置软件安装源（yum）为阿里云镜像源</p></li><li><p>安装相关工具（wget、net-tools、sshpass）、docker-ce（容器运行引擎）、docker-ce-cli（容器引擎命令行管理工具）、kubelet（k8s核心）、kubeadm（k8s部署工具）、kubectl（k8s命令行管理工具）</p></li><li><p>下载Kubernetes所依赖的Docker镜像</p></li><li><p>配置Kubernetes容器内网络（安装weave网络插件）</p></li><li><p>安装kubernetes-dashboard（Web管理工具）</p></li><li><p>配置用于远程访问的SSL证书</p></li></ol><p>工作节点配置与master前4个步骤相同，最后运行kubeadm join命令将该主机向master注册为工作节点即可。</p><h3 id="3-3-K3S集群配置"><a href="#3-3-K3S集群配置" class="headerlink" title="3.3 K3S集群配置"></a>3.3 K3S集群配置</h3><pre class="mermaid">graph TB    subgraph 阿里云    A[k3s主节点]    end    subgraph 边缘2    A --> B[边缘网关]    B --> 设备03    B --> 设备04    end    subgraph 边缘1    A --> C[边缘网关]    C --> 设备01    C --> 设备02    end</pre><p>k3s相比k8s的安装简单不少，只需要运行几句命令：</p><pre><code class="bash"># master节点curl -sfL https://get.k3s.io | sh -# 安装Web管理工具GITHUB_URL=https://github.com/kubernetes/dashboard/releasesVERSION_KUBE_DASHBOARD=$(curl -w &#39;%{url_effective}&#39; -I -L -s -S ${GITHUB_URL}/latest -o /dev/null | sed -e &#39;s|.*/||&#39;)k3s kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/${VERSION_KUBE_DASHBOARD}/aio/deploy/recommended.yaml# 编译节点export K3S_URL=39.97.114.49export K3S_TOKEN=&lt;密钥&gt;curl -sfL https://get.k3s.io | sh -</code></pre><h3 id="3-4-NFS服务器配置"><a href="#3-4-NFS服务器配置" class="headerlink" title="3.4 NFS服务器配置"></a>3.4 NFS服务器配置</h3><p>NFS 即网络文件系统（Network File System），可以通过网络让不同机器、不同系统之间可以实现文件共享。在该项目中，NFS服务负责保存集群应用中所需的配置文件和一致性文件（即在集群环境中，多台机器访问同一份文件）。通过Kubernets的Persistent Volume（持久卷），将NFS挂载到容器内，多个容器就能访问到同一份文件。</p><pre class="mermaid">graph TB    subgraph 阿里云    A[k8s主节点] --> B[k8s工作节点1]    A[k8s主节点] --> C[k8s工作节点2]    D[NFS服务器]    D -- 配置文件 --> B    D -- 配置文件 --> C    end</pre><p>NFS服务器配置如下：</p><ol><li><p>安装 NFS 软件包<code>yum install -y nfs-common nfs-utils rpcbind</code></p></li><li><p>添加 NFS 共享目录</p><p>将<code>/nfsroot</code>目录设置为NFS共享目录，设置改目录的权限为最宽松的权限<code>chmod 777 /nfsroot</code></p></li><li><p>启动NFS服务<code>/etc/init.d/nfs-kernel-server start</code></p></li></ol><h3 id="3-5-多集群管理服务配置"><a href="#3-5-多集群管理服务配置" class="headerlink" title="3.5 多集群管理服务配置"></a>3.5 多集群管理服务配置</h3><p>多集群管理服务Rancher可以在一个Web应用中管理多个k8s或k3s集群，并通过提供的API接口来通过微软云DevOps远程管理集群和部署应用。</p><pre class="mermaid">graph TB    subgraph 阿里云    A[Rancher] --> B[k8s主节点]    A --> C[k3s主节点]    end</pre><p>本项目的Rancher服务安装在独立于k8s集群的服务器中，运行在Docker容器中，使用<code>devops.zuozishi.info</code>域名的HTTPS证书，暴露6443端口访问。安装命令如下：</p><pre><code class="bash">docker run -d --restart=unless-stopped \  -p 6443:443 \  -v &lt;FULL_CHAIN.pem&gt;:/etc/rancher/ssl/cert.pem \  -v &lt;PRIVATE_KEY.pem&gt;:/etc/rancher/ssl/key.pem \  -v &lt;CA_CERTS.pem&gt;:/etc/rancher/ssl/cacerts.pem \  rancher/rancher:latest</code></pre><blockquote><p>由于域名未经备案，80端口和443端口无法使用。</p></blockquote><p>安装完成后通过地址<code>https://devops.zuozishi.info:6443</code>访问管理页面，设置初始密码。然后将k8s和k3s集群加入到管理中心。最后再新建一个远程访问API的密钥，用于远程部署应用。</p><h3 id="3-6-Azure-DevOps-Agent配置"><a href="#3-6-Azure-DevOps-Agent配置" class="headerlink" title="3.6 Azure DevOps Agent配置"></a>3.6 Azure DevOps Agent配置</h3><p>在云端架构中，采用了混合云模式。基础服务和应用运行在阿里云ECS中，可执行文件以容器的方式保存在阿里云容器镜像服务中。而代码和自动化测试编译由微软云DevOps负责。在测试编译环节中，代码需要编译成多架构版本的（包括x86_64和arm、arm64）可执行文件，同时满足在云端环境（x64）和边缘环境（arm或arm64）运行。所以当代码push到仓库时，Azure DevOps会分别在x64和arm架构服务器中编译代码，这里负责编译代码的服务器就称之为Azure DevOps Agent。Azure DevOps中会给账号分配一个免费的agent（x64架构），因为应用要在编译节点树莓派（arm架构）中运行，需要配置一台arm架构的agent服务器负责编译代码生成arm架构的可执行程序。值得一提的是，在2020年前后，arm在服务器市场越来越有优势。</p><pre class="mermaid">graph TB    A([开发者推送代码]) --> B    subgraph Azure DevOps    B[(代码仓库)]    B --> C    B --> D    B --> E    subgraph 编译    C[x86_64 Agent]    D[ARM Agent]    E[ARM64 Agent]    end    end    subgraph 阿里云    G[(阿里云容器镜像库)]    C -- x86_64架构应用镜像 --> G    D -- ARM架构应用镜像 --> G    E -- ARM64架构应用镜像 --> G    end</pre><p>Azure DevOps Agent服务配置过程如下：</p><ol><li><p>登录Azure DevOps平台</p></li><li><p>在个人中心页面中创建一个API Key用于agent用户认证</p></li><li><p>下载arm版本的agent服务程序</p></li><li><p>运行./config.sh，配置API Key</p></li><li><p>运行agent服务</p></li></ol><p><img src="https://github.com/zuozishi/ProjectEdgeDoc/raw/master/image/agent1.png" alt="配置Agent"></p><h2 id="4-边缘端架构的分析与设计"><a href="#4-边缘端架构的分析与设计" class="headerlink" title="4 边缘端架构的分析与设计"></a>4 边缘端架构的分析与设计</h2><h3 id="4-1-边缘端基础架构配置和规划"><a href="#4-1-边缘端基础架构配置和规划" class="headerlink" title="4.1 边缘端基础架构配置和规划"></a>4.1 边缘端基础架构配置和规划</h3><p>边缘端包括边缘网关和设备，边缘网关主要负责连接设备并接收和处理设备发送的数据。边缘网关作为k3s工作节点，可以通过k3s主节点进行管理，边缘应用通过k3s主节点进行下发，以容器方式运行在边缘网关，应用下发后，即使边缘网关失去了对主节点的连接，也不会影响现有应用的运行，但是无法及时对应用进行更新。</p><pre class="mermaid">graph TD    subgraph 阿里云    A[k3s主节点]    end    subgraph 边缘    A -.下发应用.-> D[边缘网关]    E[设备1] --> D    F[设备2] --> D    end</pre><p>在本项目中，使用虚拟机作为边缘网关，使用iTop-4413 ARM9开发板和树莓派4B作为边缘设备。</p><p>虚拟机的主要参数如下：</p><ul><li><p>CPU：2核</p></li><li><p>内存：4GiB</p></li><li><p>操作系统：Ubuntu 20.04 64位</p></li><li><p>系统盘：50GiB</p></li><li><p>IPv6支持</p></li></ul><p>树莓派4B的主要参数如下：</p><ul><li><p>SOC：Boradcom BCM2711</p></li><li><p>CPU：64位 1.5GHz 四核（28nm工艺）</p></li><li><p>内存：4GB LPDDR4</p></li><li><p>GPU：Boradcom VideoCore VI @ 500MHz</p></li><li><p>供电接口：Type-C（5V 3A）</p></li><li><p>WiFi网络：802.11AC 无线 2.4GHz/5GHz 双频</p></li><li><p>有线网络：真千兆以太网</p></li><li><p>操作系统：Raspbian Buster with desktop（32位系统）</p></li></ul><p>iTop-4412开发板主要参数如下：</p><ul><li><p>CPU：Exynos4412，四核Cortex-A9，主频为1.4GHz-1.6GHz</p></li><li><p>内存：2GB 双通道 DDR3</p></li><li><p>供电接口：5V/2A</p></li><li><p>有线网络：10M/100M自适应网口</p></li><li><p>I/O接口：耳机输出、MIC输入、2路串口、1路A/D、摄像头接口、WiFi接口、HDMI输出、2路USB Host、1路USB OTG、GPIO（20PIN）、LCD接口（2个LVDS接口、1个RGB接口）、MIPI接口、GPS接口、JTAG接口</p></li><li><p>操作系统：Android 4.4（API Level 19）</p></li></ul><h3 id="4-2-Aliyun-DDNS服务设计"><a href="#4-2-Aliyun-DDNS服务设计" class="headerlink" title="4.2 Aliyun-DDNS服务设计"></a>4.2 Aliyun-DDNS服务设计</h3><p>Aliyun-DDNS负责把边缘网关的外部IPv4和IPv6地址通过阿里云DNS解析服务解析到域名<code>&lt;边缘网关主机名&gt;.zuozishi.online</code>，如果边缘网关使用公网IP或支持IPv6网络，则可以通过解析的域名直接能远程访问到边缘网关，方便管理。</p><h3 id="4-3-frp服务设计"><a href="#4-3-frp服务设计" class="headerlink" title="4.3 frp服务设计"></a>4.3 frp服务设计</h3><p>frps服务主要针对于IPv4的NAT网络和非IPv6网络环境中，是对边缘网关进行远程访问的一种额外手段，通过端口转发方式，将处于内网的边缘网关通过frp服务将边缘网关的某个端口映射到具有公网IP主机的某个端口上。</p><pre class="mermaid">sequenceDiagram    内网主机->>公网主机: 通过7000端口连接到frps服务    Note over 内网主机,公网主机: frp服务生命周期内保持连接    内网主机->>公网主机: 注册配置文件    Note over 内网主机,公网主机: frps和frpc端口映射关系    客户端->>公网主机: 通过8080端口访问    公网主机->>内网主机: 通过7000端口长连接请求8080端口数据    内网主机->>公网主机: 网页数据    公网主机->>客户端: 网页数据</pre><blockquote><p>frps：指frp server（frp服务端，公网主机）<br>frpc：指frp client（frp客户端，内网主机）</p></blockquote><h3 id="4-4-服务发现（SSDP）"><a href="#4-4-服务发现（SSDP）" class="headerlink" title="4.4 服务发现（SSDP）"></a>4.4 服务发现（SSDP）</h3><p>边缘物联网设备通过服务发现来找到局域网中可以连接的边缘网关，服务发现使用简单服务发现协议（SSDP，Simple Service Discovery Protocol）实现。边缘网关通过SSDP协议在网络中注册为UPnP边缘网关设备，通过Kubernetes API（边缘网关为k3s，但是API是兼容的）将可用的边缘应用作为UPnP属性。物联网设备端扫描网络中可用的UPnP设备，通过UPnP设备属性判断局域网中有没有可用的边缘网关,然后通过SSDP协议中的xml链接获取UPnP设备描述文件，设备描述文件包括边缘网关中运行的服务和服务端口号，然后设备端进行连接。</p><blockquote><p>简单服务发现协议（SSDP）是一种应用层协议，是构成通用即插即用(UPnP)技术的核心协议之一。简单服务发现协议提供了在局部网络里面发现设备的机制。</p></blockquote><pre class="mermaid">sequenceDiagram    边缘设备->>边缘网关: 发送M-SEARCH UDP广播    边缘网关->>边缘设备: 响应搜索请求    边缘设备->>边缘网关: 获取UPnP设备描述文件    边缘网关->>边缘设备: 响应设备信息和服务信息    边缘设备->>边缘网关: 通过服务端口连接服务</pre><p>边缘网关SSDP服务使用JavaScript语言开发，运行在NodeJS环境，使用express组件提供HTTP协议服务。<br>主要代码如下：</p><pre><code class="JavaScript">// 注册为UPnP设备server.addUSN(&#39;upnp:rootdevice&#39;)// 注册为边缘网关server.addUSN(&#39;urn:schemas-upnp-org:device:EdgeGateway:1&#39;)// 注册k3s-nodePort类型服务发现服务server.addUSN(&#39;urn:schemas-upnp-org:service:k3s-nodePort-Service:1&#39;)// 启动SSDP服务server.start()    .catch(e =&gt; {        console.log(&#39;SSDP服务启动失败:&#39;, e)    })    .then(() =&gt; {        console.log(&#39;SSDP服务已启动&#39;)    })// 注册UPnP设备描述文件访问路径app.get(&#39;/device.xml&#39;, (req, res) =&gt; {    res.contentType(&#39;text/xml&#39;)    // 从文件中读取    var xml = fs.readFileSync(&#39;./device.xml&#39;, &#39;utf8&#39;).toString()    // 替换主机名    xml = xml.replace(&#39;{hostname}&#39;, os.hostname()).replace(&#39;{hostname}&#39;, os.hostname())    // HTTP请求返回数据    res.send(xml)})// 注册k3s服务发现访问路径app.get(&#39;/service&#39;, (req, res) =&gt; {     res.contentType(&#39;application/json&#39;)    var services = []    // 通过Rancher API查询k3s服务    rp({        uri: &#39;https://devops.zuozishi.info:6443/v3/project/c-cx29q:p-2hlhh/services/&#39;,        headers: {            &#39;Authorization&#39;: &#39;Bearer &lt;token&gt;&#39;        },        json: true    }).then((obj) =&gt; {        if (&#39;data&#39; in obj) {            // 遍历所有服务            obj[&#39;data&#39;].forEach(item =&gt; {                // 找到类型为NodePort的服务                if (item[&#39;kind&#39;] == &#39;NodePort&#39; &amp;&amp; &#39;publicEndpoints&#39; in item) {                    item[&#39;publicEndpoints&#39;].forEach(endpoint =&gt; {                        var service = endpoint                        service[&#39;name&#39;] = item[&#39;name&#39;]                        service[&#39;namespace&#39;] = item[&#39;namespaceId&#39;]                        services.push(service)                    })                }            });        }        // HTTP请求返回数据        res.send(services)    }).catch((e) =&gt; {        // HTTP请求返回数据        res.send(services)    })})</code></pre><h2 id="5-应用的设计与实现"><a href="#5-应用的设计与实现" class="headerlink" title="5. 应用的设计与实现"></a>5. 应用的设计与实现</h2><h3 id="5-1-音乐播放服务"><a href="#5-1-音乐播放服务" class="headerlink" title="5.1 音乐播放服务"></a>5.1 音乐播放服务</h3><h4 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h4><p>音乐播放服务运行在边缘端，提供用户登录、实时控制、播放列表、网络资源搜索等功能。基于ASP Net Core框架，使用Visual Studio IDE进行开发，开发语言：C#。</p><blockquote><p>.NET Core是一个能在Windows、Linux、macOS平台上运行Web服务和命令行应用的跨平台的.NET框架。</p></blockquote><p>音乐播放服务主要使用了ASP Net Core的三大模块：API Controller、Razor Pages、SignalR Hub。</p><ul><li>API Controller: 提供音乐搜索、用户登录、播放列表等RESTful API</li><li>Razor Pages: 提供网页页面、渲染页面</li><li>SignalR Hub: 提供播放器和播放控制端的实时通信通道（实现实时控制和日志上报）</li></ul><h4 id="5-1-2-RESTful-API设计"><a href="#5-1-2-RESTful-API设计" class="headerlink" title="5.1.2 RESTful API设计"></a>5.1.2 RESTful API设计</h4><p>RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义（项目中使用JSON格式）。API分为登录、在线资源、播放列表大三类别，服务使用酷狗用户认证。</p><ol><li>登录相关：</li></ol><table><thead><tr><th>方法</th><th>路径</th><th>功能</th><th>请求参数</th></tr></thead><tbody><tr><td>PSOT</td><td>api/login/update</td><td>更新用户Cookie</td><td>Cookie（body）</td></tr><tr><td>GET</td><td>api/login/check</td><td>检测用户Cookie是否有效</td><td>Cookie（header）</td></tr></tbody></table><ol start="2"><li>在线资源相关：</li></ol><table><thead><tr><th>方法</th><th>路径</th><th>功能</th><th>请求参数</th></tr></thead><tbody><tr><td>GET</td><td>api/presearch/{keyword}</td><td>获取预搜索结果</td><td>keyword-关键词</td></tr><tr><td>GET</td><td>api/search/{keyword}</td><td>搜索网络资源</td><td>keyword-关键词</td></tr><tr><td>GET</td><td>api/search/{keyword}/source</td><td>搜索并返回第一个播放源</td><td>keyword-关键词</td></tr><tr><td>GET</td><td>api/song/{hash}</td><td>获取歌曲信息</td><td>hash-歌曲哈希值</td></tr><tr><td>GET</td><td>api/mv/{hash}</td><td>获取MV信息</td><td>hash-MV哈希值</td></tr><tr><td>GET</td><td>api/mv/{hash}/source}</td><td>获取MV播放源</td><td>hash-MV哈希值</td></tr><tr><td>GET</td><td>api/lrc/{keyword}/{duration}</td><td>获取歌词</td><td>hash-歌曲哈希值<br />duration-歌曲总时长</td></tr></tbody></table><ol start="3"><li>播放列表相关：</li></ol><table><thead><tr><th>方法</th><th>路径</th><th>功能</th><th>请求参数</th></tr></thead><tbody><tr><td>GET</td><td>playlist/isfav/{mid}</td><td>判断是否是喜欢的音乐</td><td>mid-音乐ID</td></tr><tr><td>GET</td><td>api/playlist/fav</td><td>获取喜欢的音乐列表</td><td>keyword-关键词</td></tr><tr><td>POST</td><td>api/playlist/fav</td><td>将歌曲添加到喜欢的音乐</td><td>歌曲JSON数据（body）</td></tr><tr><td>DELETE</td><td>api/playlist/fav/{mid}</td><td>将歌曲从喜欢的音乐列表中移除</td><td>mid-音乐ID</td></tr><tr><td>GET</td><td>api/playlist/all</td><td>获取全部播放列表</td><td></td></tr><tr><td>POST</td><td>api/playlist/song/{id}</td><td>将歌曲添加到播放列表</td><td>歌曲JSON数据（body）</td></tr><tr><td>DELETE</td><td>api/playlist/song/{id}/{mid}</td><td>将歌曲从播放乐列表中移除</td><td>id-播放列表ID<br />mid-音乐ID</td></tr><tr><td>GET</td><td>api/playlist/isin/{id}/{mid}</td><td>判断音乐是否在播放列表中</td><td>id-播放列表ID<br />mid-音乐ID</td></tr></tbody></table><h4 id="5-1-3-SignalR消息定义"><a href="#5-1-3-SignalR消息定义" class="headerlink" title="5.1.3 SignalR消息定义"></a>5.1.3 SignalR消息定义</h4><p>ASP.NET Core SignalR是一种开放源代码库，可简化将实时 web 功能添加到应用程序的功能。 实时 web 功能使服务器端代码可以立即将内容推送到客户端。SignalR会自动选择服务器和客户端功能内的最佳传输方法，包括：WebSocket、服务器发送的事件、长轮询。</p><p>SignalR使用“中心”在客户端和服务器之间进行通信。“中心”是一种高级管道，它允许客户端和服务器分别调用方法。 SignalR自动处理跨计算机边界的调度，使客户端能够在服务器上调用方法，反之亦然。 可以将强类型参数传递给方法，从而启用模型绑定。 SignalR提供了两个内置的集线器协议：基于 JSON 的文本协议和基于MessagePack的二进制协议。 与 JSON 相比，MessagePack 通常会创建较小的消息。</p><p>音乐播放服务的SignalR“中心”接口定义如下表：</p><table><thead><tr><th align="center">函数名</th><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">WriteLog</td><td align="center">日志类别, 消息</td><td align="center">上报日志</td></tr><tr><td align="center">RegisterPlayer</td><td align="center">播放器ID</td><td align="center">注册为播放器</td></tr><tr><td align="center">RegisterClient</td><td align="center">客户端ID,客户端群组ID</td><td align="center">注册为客户端</td></tr><tr><td align="center">PropertyChanged</td><td align="center">JSON数据</td><td align="center">播放器数据变动</td></tr><tr><td align="center">RequireData</td><td align="center">无</td><td align="center">请求播放器重发数据</td></tr><tr><td align="center">PlayListChanged</td><td align="center">播放列表ID</td><td align="center">播放列表变动</td></tr><tr><td align="center">EnumPlayers</td><td align="center">无</td><td align="center">枚举播放器</td></tr><tr><td align="center">EnumPlayersCallback</td><td align="center">播放器ID</td><td align="center">枚举播放器回调</td></tr><tr><td align="center">SearchAndPlay</td><td align="center">关键词</td><td align="center">搜索并播放</td></tr><tr><td align="center">MediaCtrl</td><td align="center">类别,数据</td><td align="center">媒体控制</td></tr></tbody></table><p>无论任何语言和任何平台，只要播放端和控制端满足上述接口定义，就能实现远程音乐播放器控制。</p><h4 id="5-1-4-网页页面设计"><a href="#5-1-4-网页页面设计" class="headerlink" title="5.1.4 网页页面设计"></a>5.1.4 网页页面设计</h4><p>服务提供两个页面，主页和API文档。主页可以对连接到服务的播放器进行控制，支持歌词/进度显示、搜索并播放、播放列表控制、上一曲、下一曲、播放/暂停、音量控制。服务端使用使用Razor渲染页面，页面使用bootstrap作为UI框架，使用VUE.js进行数据绑定，使用SignalR Client库与SignalR“中心”连接。API文档由Swagger自动从代码生成API文档页面。</p><h4 id="5-1-5-容器化服务"><a href="#5-1-5-容器化服务" class="headerlink" title="5.1.5 容器化服务"></a>5.1.5 容器化服务</h4><p>使用Docker和Dockerfile文件将程序编译，并打包成镜像。Dockerfile打包过程如下：</p><ol><li>使用dotnet/core/aspnet:3.0-buster-slim作为基准镜像</li><li>使用dotnet/core/sdk:3.0-buster作为编译环境镜像</li><li>设定工作目录为/app</li><li>拷贝代码到容器中</li><li>下载程序所依赖的第三方库</li><li>编译</li><li>将基准镜像作为最终运行镜像</li><li>保留服务端口：81</li><li>复制编译后的dll到当前文件夹</li><li>设置容器入口命令：dotnet MusicCloud.dll</li></ol><h4 id="5-1-6-Kubernetes服务定义"><a href="#5-1-6-Kubernetes服务定义" class="headerlink" title="5.1.6 Kubernetes服务定义"></a>5.1.6 Kubernetes服务定义</h4><p>项目中的<code>kubernetes.k8s.yaml</code>文件定义了音乐播放服务在Kubernets集群中的注册信息。<code>kubernetes.k3s.yaml</code>文件定义了音乐播放服务在k3s集群中的注册信息。<br>在k8s集群中，使用Deployment调度3个容器运行服务，将NFS PVC映射到容器中<code>/nfs-pvc</code>路径，使用阿里云镜像密钥从阿里云镜像库拉取镜像，注册一个服务，将宿主机的30005端口映射到容器的81端口。<br>在k3s集群中，使用DaemonSet在每个编译节点都调度一个音乐播放服务，使用阿里云镜像密钥从阿里云镜像库拉取镜像，注册一个服务，将宿主机的30005端口映射到容器的81端口。</p><h4 id="5-1-7-自动化编译-部署"><a href="#5-1-7-自动化编译-部署" class="headerlink" title="5.1.7 自动化编译/部署"></a>5.1.7 自动化编译/部署</h4><p>项目中的<code>azure-pipelines.yml</code>文件定义了项目代码提交到远程代码库时，触发Azure Pielines运行时所需要执行的编译/部署步骤。</p><ol><li>编译镜像</li><li>将镜像推送到阿里云容器镜像库</li><li>配置Kubernetes应用部署文件</li><li>上传应用部署文件</li><li>部署应用</li></ol><h3 id="5-2-音乐播放器和音乐控制端"><a href="#5-2-音乐播放器和音乐控制端" class="headerlink" title="5.2 音乐播放器和音乐控制端"></a>5.2 音乐播放器和音乐控制端</h3><h4 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h4><p>音乐播放器和音乐控制端基于谷歌Flutter框架，使用Dart语言，以Visual Studio Code作为IDE进行开发。音乐播放器运行在Android 4.4系统的ARM开发板上，可以连接外设，音乐控制端支持Android和iOS。</p><blockquote><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。</p></blockquote><p>音乐播放器和音乐控制端使用同一套源码，通过获取设备信息来判断加载播放器UI还是加载控制端UI。音乐播放器和音乐控制端都通过简单服务发现协议（SSDP）搜索局域网中可以连接的边缘网关，连接到音乐播放服务的SignalR“中心”，分别注册为播放器和客户端。播放器接收客户端的控制指令，并上报音乐播放状态和播放列表。控制端向播放端发送控制指令，并接收音乐播放状态和播放列表。播放器使用酷狗客户端扫描二维码方式登录账号，通过API进行资源搜索、访问/修改播放列表、更新Cookie。</p><pre class="mermaid">graph TD    subgraph 边缘网关    A[SSDP服务]    B[音乐播放服务]    B -.服务名和端口号.-> A    end    C[播放器] -.UDP广播包.-> A    D[控制端] -.UDP广播包.-> A    C --> B    D --> B</pre><h4 id="5-2-2-播放器UI设计"><a href="#5-2-2-播放器UI设计" class="headerlink" title="5.2.2 播放器UI设计"></a>5.2.2 播放器UI设计</h4><p>播放器端包含四个页面：二维码登录页面、播放主页面、播放列表页面、推荐页面。<br>播放主页面的元素包括：图片背景、播放时会旋转的专辑封面、上一曲/下一曲/播放/暂停控制按钮、收藏按钮、播放进度时间文本、歌曲名/歌手标签、音量控制条、两行歌词文本。播放列表页面显示用户所有的播放列表和当前正在播放的列表。推荐页面根据当前正在播放的音乐显示推荐的更多音乐和歌单。</p><h4 id="5-2-3-播放器程序逻辑"><a href="#5-2-3-播放器程序逻辑" class="headerlink" title="5.2.3 播放器程序逻辑"></a>5.2.3 播放器程序逻辑</h4><p>程序开始运行时，首先通过SSDP协议扫描局域网中的边缘网关，然后通过SignalR协议连接边缘网关中运行的音乐播放服务，通过SignalR协议调用“中心”的RegisterPlayer方法将当前连接注册为播放器。通过HTTP调用<code>api/login/check</code> API判断用户是否已经登录，如果没有登录则显示二维码登录页面，如果用户已经登录则显示播放器主页。播放器注册SignalR“中心”MediaCtrl方法，监听控制端的数据。当音乐播放状态改变时，调用SignalR“中心”的PropertyChanged（播放器数据变动）、PlayListChanged（播放列表变动）方法向控制端上报最新数据。</p><h4 id="5-2-4-控制端UI设计"><a href="#5-2-4-控制端UI设计" class="headerlink" title="5.2.4 控制端UI设计"></a>5.2.4 控制端UI设计</h4><p>控制端有多个页面，主要的有：播放主页面、播放列表、推荐页面、乐库、每日歌曲推荐、排行榜、搜索和搜索结果页面。</p><ul><li>播放主页面：显示当前音乐播放状态（进度、歌词）、音乐控制（上一曲/下一曲/播放/暂停）。</li><li>播放列表：显示当前播放列表，支持删除、另存为播放列表。</li><li>推荐页面：通过调用酷狗API，基于当前播放的音乐推荐其他音乐和歌单。</li><li>每日歌曲推荐：通过调用酷狗API，根据用户习惯推荐音乐。</li><li>搜索和搜索结果页面:通过调用酷狗API，搜索网络音乐，选择可以立即播放或添加到播放列表。</li></ul><h4 id="5-2-5-控制端程序逻辑"><a href="#5-2-5-控制端程序逻辑" class="headerlink" title="5.2.5 控制端程序逻辑"></a>5.2.5 控制端程序逻辑</h4><p>程序开始运行时，首先通过SSDP协议扫描局域网中的边缘网关，然后通过SignalR协议连接边缘网关中运行的音乐播放服务，通过SignalR协议调用“中心”的RegisterClient方法将当前连接注册为音乐控制器。程序注册SignalR“中心”的PropertyChanged方法监听播放器上报的音乐播放状态。用户操作时，调用MediaCtrl方法控制播放器。</p><h3 id="5-3-基于树莓派的音乐控制器"><a href="#5-3-基于树莓派的音乐控制器" class="headerlink" title="5.3 基于树莓派的音乐控制器"></a>5.3 基于树莓派的音乐控制器</h3><h4 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h4><p>在本项目应用示例中，任何设备只需要先通过简单服务发现协议查找到边缘网关的服务入口，然后通过SignalR协议连接到音乐播放服务，注册为播放器或客户端（控制器）就能根据特定规则（SingalR“中心”方法）完成特定的功能。<br>基于树莓派的音乐控制器通过GPIO按钮实现控制播放器上一曲/下一曲/播放/暂停，通过LCD 20*4显示屏显示音乐播放状态（播放器名、音量、当前歌曲剩余时间、播放进度条、边缘网关IP），通过RFID读卡器导入/导出播放列表，通过IR红外接收器使用遥控器和小爱同学控制音乐播放。</p><h4 id="5-3-2-硬件设计"><a href="#5-3-2-硬件设计" class="headerlink" title="5.3.2 硬件设计"></a>5.3.2 硬件设计</h4><p>硬件清单：</p><table><thead><tr><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>树莓派 4B</td><td>1</td></tr><tr><td>树莓派接口扩展器</td><td>1</td></tr><tr><td>RC522 RFID读卡器</td><td>1</td></tr><tr><td>GPIO按钮</td><td>4</td></tr><tr><td>I2C LCD2004 液晶显示屏</td><td>1</td></tr><tr><td>IR红外解码/编码模块</td><td>1</td></tr><tr><td>USB-TTL（USB转串行口）</td><td>1</td></tr><tr><td>蓝色LED灯</td><td>1</td></tr><tr><td>100 kΩ电阻</td><td>1</td></tr></tbody></table><p>硬件接线图：<br><img src="https://github.com/zuozishi/ProjectEdgeDoc/raw/master/image/Sketch%E7%94%B5%E8%B7%AF%E5%9B%BE.png" alt="接线图"></p><p><img src="https://github.com/zuozishi/ProjectEdgeDoc/raw/master/image/rfid-rc522.png" alt="RFID-RC522"></p><p>重要外设介绍：</p><ul><li><p>RFID-RC522 RFID读卡器<br>RC522模块是基于射频基站芯片的Mifare卡读写模块，模块工作再13.56MHz频率，可支持Mifare 1S50、Mifare 1S70、Mifare Light、Mifare Ultralight、Mifare Pro。模块具有易用、高可靠、体积小等特点，可以帮助客户方便、快捷的将非接触卡应用到系统中.</p></li><li><p>I2C LCD2004 液晶显示屏<br>众所周知，LCD液晶显示屏虽然极大地丰富了人机交互，但他们有一个共同的弱点。当它们连接到主控制器时，会占用主控制器的多个IO接口，同时也限制了主控制器的其他功能。因此，通常利用PCF8574系列芯片通过IIC总线扩展多个IO接口来驱动LCD显示屏。IIC总线是由PHLIPS发明的一种串行总线。它是一种高性能串行总线，具有多主机系统所要求的总线控制和高速或低速设备同步功能。IIC总线只有两个双向信号线，串行数据线(SDA)和串行时钟线(SCL)。I2C LCD2004上的蓝色电位计用于调整背光，使其更易于在I2C LCD2004上显示。</p></li></ul><h4 id="5-3-3-软件设计"><a href="#5-3-3-软件设计" class="headerlink" title="5.3.3 软件设计"></a>5.3.3 软件设计</h4><p>软件运行环境基于.Net Core，.Net Core可用于为物联网设备和场景构建应用程序，物联网应用通常与需要使用GPIO引脚、串口或类似硬件的传感器、显示器和输入设备进行交互。<code>System.Device.Gpio</code>命名空间中包含了对 硬件底层的访问（GPIO、SPI、IIC、Serial），<code>Iot.Device.Bindings</code>命名空间包含了硬件的绑定（具体的外设），由社区开发者维护。<br>使用Visual Studio Code作为IDE进行开发，结合vscode的SFTP插件，通过SFTP协议，代码变动时自动将代码上传到树莓派。<code>dotnet watch run</code>命令可以监测代码文件的变动，代码变动时自动重新编译运行。</p><p>重要类(class)设计：</p><table><thead><tr><th>构造函数</th><th>说明</th><th>参数</th></tr></thead><tbody><tr><td>GpioButton(int pin)</td><td>表示一个GPIO按钮，提供按钮按下的事件</td><td>pin - 引脚编号</td></tr><tr><td>GpioLed(int pin)</td><td>表示一个LED灯，提供开(On)灯、关灯(Off)方法</td><td>pin - 引脚编号</td></tr><tr><td>IR(string portName, int baudRate)</td><td>表示一个红外接收器，提供收到红外信号的事件</td><td>portName - 串行口设备地址，baudRate - 波特率</td></tr><tr><td>LCD2004(int address)</td><td>表示LCD屏幕，提供清屏/输出/显示进度条方法</td><td>address - IIC设备地址</td></tr><tr><td>Mfrc522Lib()</td><td>表示RFID读卡器，提供读卡ID事件</td><td></td></tr><tr><td>MusicServerDiscover()</td><td>通过SSDP协议扫描边缘网关，提供音乐服务连接入口</td><td></td></tr><tr><td>RemotePlayer(string url)</td><td>表示远程播放器，提供控制设备方法(MediaCtrl)和播放器属性变动事件</td><td>url-音乐服务连接入口</td></tr><tr><td>PlayerReportProperty()</td><td>表示音乐播放器属性（包括：当前播放列表、音量、播放进度、歌词等）</td><td></td></tr></tbody></table><p>程序工作流程：</p><ol><li>初始化硬件（GPIO、LCD、红外接收器、RFID读卡器）</li><li>扫描边缘网关</li><li>获取音乐服务入口</li><li>连接到SignalR“中心”</li><li>注册为客户端</li><li>注册播放器属性变动事件</li><li>主线程延时死循环</li></ol><p>初始化主要代码：</p><pre><code class="csharp">static GpioController controller;static GpioLed led;static Mfrc522 rfid;static GpioButton btn1;static GpioButton btn2;static GpioButton btn3;static GpioButton btn4;static IR ir;static LCD2004 lcd;static RemotePlayer player;static PlayerReportProperty playerProperty;static string rfidMode = &quot;&quot;;static void Main(string[] args){  playerProperty = new PlayerReportProperty();  try  {    controller = new GpioController();    Console.WriteLine(&quot;初始化LED...&quot;);    led = new GpioLed(controller, 26);    led.Off();    Console.WriteLine(&quot;初始化GPIO按键...&quot;);    btn1 = new GpioButton(controller, 12);    btn1.ButtonPressed += ButtonPressed;    btn2 = new GpioButton(controller, 16);    btn2.ButtonPressed += ButtonPressed;    btn3 = new GpioButton(controller, 20);    btn3.ButtonPressed += ButtonPressed;    btn4 = new GpioButton(controller, 21);    btn4.ButtonPressed += ButtonPressed;    Console.WriteLine(&quot;初始化LCD...&quot;);    lcd = new LCD2004(0x27);    lcd.WriteLine(0, &quot;Cloud Player&quot;);    lcd.WriteLine(3, &quot;Wait to find server&quot;);    Console.WriteLine(&quot;初始化RFID读卡器...&quot;);    rfid = new Mfrc522();    rfid.InitIO(controller).Wait();    rfid.StartFound();    rfid.CardFound += FoundRfidCard;    Console.WriteLine(&quot;初始化红外接收器...&quot;);    ir = new IR(&quot;/dev/ttyUSB0&quot;, 9600);    ir.IR_Received += IR_Received;  }  catch (Exception e)  {    Console.WriteLine(e.Message);    Console.WriteLine(&quot;非树莓派运行!!!&quot;);  }  Console.WriteLine(&quot;初始化完成，等待连接服务器。&quot;);  player = new RemotePlayer();  // 播放器连接事件  player.PlayerConnectEvent += (id) =&gt;  {    if (id == null)    {      led?.Off();      lcd?.WriteLine(0, &quot;No Player&quot;);    }    else    {      led?.On();      lcd?.WriteLine(0, id);    }  };  // 服务器连接事件  player.ServerConnectEvent += (url) =&gt;  {    var uri = new Uri(url);    lcd?.WriteLine(3, uri.Host);  };  // 注册播放器属性变动事件  player.PlayerProperty += PlayerProperty;  while (true)  {    Thread.Sleep(1000 * 60);  }}</code></pre><p>硬件事件监听代码：</p><pre><code class="csharp">/// &lt;summary&gt;/// RFID读卡事件/// &lt;/summary&gt;/// &lt;param name=&quot;dev&quot;&gt;读卡器&lt;/param&gt;/// &lt;param name=&quot;id&quot;&gt;卡号&lt;/param&gt;static void FoundRfidCard(Mfrc522 dev, Uid id){    if(rfidMode == &quot;load&quot;){        // 加载播放列表并播放        player.MediaCtrl(&quot;PlayPlayList&quot;, &quot;rfid:&quot; + id.ToString());        rfidMode = &quot;&quot;;        lcd?.WriteLine(3, new Uri(player.url).Host);    }else if(rfidMode == &quot;save&quot;){        // 保存当前播放列表        player.MediaCtrl(&quot;SavePlayList&quot;, &quot;rfid:&quot; + id.ToString());        rfidMode = &quot;&quot;;        lcd?.WriteLine(3, new Uri(player.url).Host);    }}/// &lt;summary&gt;/// GPIO按键按下事件/// &lt;/summary&gt;/// &lt;param name=&quot;pin&quot;&gt;引脚号&lt;/param&gt;static void ButtonPressed(int pin){    Console.WriteLine(&quot;按键: &quot; + pin.ToString());    if (player == null) return;    switch (pin)    {        // 上一曲        case 12: player.MediaCtrl(&quot;ctrl&quot;, &quot;previous&quot;); break;        // 播放/暂停        case 16: player.MediaCtrl(&quot;ctrl&quot;, &quot;play&quot;); break;        // 下一曲        case 20: player.MediaCtrl(&quot;ctrl&quot;, &quot;next&quot;); break;        default: break;    }    if(pin == 21)    {        // 切换RFID卡功能模式（加载播放列表或保存播放列表）        if(rfidMode == &quot;&quot;)        {            rfidMode = &quot;load&quot;;            lcd?.WriteLine(3, &quot;Load playlist ...&quot;);        }else if(rfidMode == &quot;load&quot;)        {            rfidMode = &quot;save&quot;;            lcd?.WriteLine(3, &quot;Save playlist ...&quot;);        }else if(rfidMode == &quot;save&quot;){            rfidMode = &quot;&quot;;            lcd?.WriteLine(3, new Uri(player.url).Host);        }    }}/// &lt;summary&gt;/// 红外接收事件/// &lt;/summary&gt;/// &lt;param name=&quot;code&quot;&gt;按键码&lt;/param&gt;static void IR_Received(string code){    Console.WriteLine(&quot;红外接收: &quot; + code);    switch (code)    {        // 播放/暂停        case &quot;00bf15&quot;: player.MediaCtrl(&quot;ctrl&quot;, &quot;play&quot;); break;        // 上一曲        case &quot;00bf16&quot;: player.MediaCtrl(&quot;ctrl&quot;, &quot;previous&quot;); break;        // 下一曲        case &quot;00bf17&quot;: player.MediaCtrl(&quot;ctrl&quot;, &quot;next&quot;); break;        // 音量-        case &quot;00bf19&quot;: player.MediaCtrl(&quot;ctrl&quot;, &quot;vold&quot;); break;        // 音量+        case &quot;00bf18&quot;: player.MediaCtrl(&quot;ctrl&quot;, &quot;volu&quot;); break;        default: break;    }}</code></pre><h2 id="6-服务关键代码及配置"><a href="#6-服务关键代码及配置" class="headerlink" title="6 服务关键代码及配置"></a>6 服务关键代码及配置</h2><h3 id="6-1-AliyunDDNS服务"><a href="#6-1-AliyunDDNS服务" class="headerlink" title="6.1 AliyunDDNS服务"></a>6.1 AliyunDDNS服务</h3><ul><li>ddns.py</li></ul><pre><code class="python">import osimport jsonimport requestsfrom aliyunsdkcore.client import AcsClientfrom aliyunsdkcore.request import CommonRequest# 阿里云API密钥keyid = os.environ[&quot;ALIYUN_KEYID&quot;].replace(&#39;\n&#39;,&#39;&#39;)secret = os.environ[&quot;ALIYUN_SECRET&quot;].replace(&#39;\n&#39;,&#39;&#39;)# 域名domain = os.environ[&quot;ALIYUN_DOMAIN&quot;].replace(&#39;\n&#39;, &#39;&#39;)host = &quot;test&quot;if os.path.exists(&#39;/etc/hostname&#39;):    file = open(&#39;/etc/hostname&#39;, &#39;r&#39;)    host = file.read().replace(&#39;\n&#39;, &#39;&#39;)    file.close()if &quot;ALIYUN_DDNS_HOST&quot; in os.environ:    host = os.environ[&quot;ALIYUN_DDNS_HOST&quot;].replace(&#39;\n&#39;, &#39;&#39;)print(&#39;主机名：&#39;, host)print(&#39;域名：&#39;, domain)client = AcsClient(keyid, secret, &#39;cn-hangzhou&#39;)# 检测是否已经有记录def checkRecord(type):    req = CommonRequest()    req.set_accept_format(&#39;json&#39;)    req.set_domain(&#39;alidns.aliyuncs.com&#39;)    req.set_method(&#39;POST&#39;)    req.set_version(&#39;2015-01-09&#39;)    req.set_action_name(&#39;DescribeSubDomainRecords&#39;)    req.add_query_param(&#39;Type&#39;, type)    req.add_query_param(&#39;SubDomain&#39;, host+&quot;.&quot;+domain)    response = client.do_action(req)    obj = json.loads(str(response, encoding=&#39;utf-8&#39;))    print(&#39;checkRecord&#39;, obj)    if &quot;TotalCount&quot; not in obj:        return False    if obj[&quot;TotalCount&quot;] &gt; 0:        return True    else:        return False# 删除记录def delRecord(type):    req = CommonRequest()    req.set_accept_format(&#39;json&#39;)    req.set_domain(&#39;alidns.aliyuncs.com&#39;)    req.set_method(&#39;POST&#39;)    req.set_version(&#39;2015-01-09&#39;)    req.set_action_name(&#39;DeleteSubDomainRecords&#39;)    req.add_query_param(&#39;Type&#39;, type)    req.add_query_param(&#39;DomainName&#39;, domain)    req.add_query_param(&#39;RR&#39;, host)    response = client.do_action(req)    obj = json.loads(str(response, encoding=&#39;utf-8&#39;))    print(&#39;delRecord&#39;, obj)    if obj[&quot;RR&quot;] == host:        return True    else:        return False# 添加记录def addRecord(ip, type):    req = CommonRequest()    req.set_accept_format(&#39;json&#39;)    req.set_domain(&#39;alidns.aliyuncs.com&#39;)    req.set_method(&#39;POST&#39;)    req.set_version(&#39;2015-01-09&#39;)    req.set_action_name(&#39;AddDomainRecord&#39;)    req.add_query_param(&#39;DomainName&#39;, domain)    req.add_query_param(&#39;RR&#39;, host)    req.add_query_param(&#39;Type&#39;, type)    req.add_query_param(&#39;Value&#39;, ip)    response = client.do_action(req)    obj = json.loads(str(response, encoding=&#39;utf-8&#39;))    print(&#39;addRecord&#39;, obj)    return obj[&quot;RecordId&quot;]# 获取IPv4公网地址def getIp4Addres():    obj = requests.get(        &quot;http://ipv4.lookup.test-ipv6.com/ip/?asn=1&amp;testdomain=test-ipv6.com&amp;testname=test_asn4&quot;).json()    print(&quot;IPv4&quot;, obj)    return obj[&quot;ip&quot;]# 获取IPv6公网地址def getIp6Addres():    obj = requests.get(        &quot;http://ipv6.lookup.test-ipv6.com/ip/?asn=1&amp;testdomain=test-ipv6.com&amp;testname=test_asn6&quot;).json()    print(&quot;IPv6&quot;, obj)    return obj[&quot;ip&quot;]try:    if checkRecord(&#39;A&#39;):        print(&quot;删除域名中已有的IPv4解析数据&quot;)        delRecord(&#39;A&#39;)    if checkRecord(&#39;AAAA&#39;):        print(&quot;删除域名中已有的IPv6解析数据&quot;)        delRecord(&#39;AAAA&#39;)    ip = getIp4Addres()    print(&quot;本机IPv4地址：&quot; + ip)    recid = addRecord(ip, &#39;A&#39;)    print(&quot;已向域名添加解析记录，ID：&quot; + recid)    ipv6 = getIp6Addres()    print(&quot;本机IPv6地址：&quot; + ipv6)    recid = addRecord(ipv6, &#39;AAAA&#39;)    print(&quot;已向域名添加解析记录，ID：&quot; + recid)    passexcept:    passos.system(&#39;sleep 1800&#39;)</code></pre><h3 id="6-2-edge-ssdp服务"><a href="#6-2-edge-ssdp服务" class="headerlink" title="6.2 edge-ssdp服务"></a>6.2 edge-ssdp服务</h3><ul><li>index.js</li></ul><pre><code class="JavaScript">const rp = require(&#39;request-promise&#39;);const express = require(&#39;express&#39;)const convert = require(&#39;xml-js&#39;)const fs = require(&#39;fs&#39;)const os = require(&#39;os&#39;)const app = express()const port = 49154var SSDP = require(&#39;node-ssdp&#39;).Server    , server = new SSDP({        location: {            port: port,            path: &#39;/device.xml&#39;        }    })// 注册为UPnP设备server.addUSN(&#39;upnp:rootdevice&#39;)// 注册为边缘网关server.addUSN(&#39;urn:schemas-upnp-org:device:EdgeGateway:1&#39;)// 注册k3s-nodePort类型服务发现服务server.addUSN(&#39;urn:schemas-upnp-org:service:k3s-nodePort-Service:1&#39;)server.on(&#39;advertise-alive&#39;, function (headers) {})server.on(&#39;advertise-bye&#39;, function (headers) {})// 启动SSDP服务server.start()    .catch(e =&gt; {        console.log(&#39;SSDP服务启动失败:&#39;, e)    })    .then(() =&gt; {        console.log(&#39;SSDP服务已启动&#39;)    })process.on(&#39;exit&#39;, function () {    server.stop()})// 注册k3s服务发现访问路径app.get(&#39;/service&#39;, (req, res) =&gt; {    res.contentType(&#39;application/json&#39;)    var services = []    // 通过Rancher API查询k3s服务    rp({        uri: &#39;https://devops.zuozishi.info:6443/v3/project/c-cx29q:p-2hlhh/services/&#39;,        headers: {            &#39;Authorization&#39;: &#39;Bearer token-scvtk:&lt;token&gt;&#39;        },        json: true    }).then((obj) =&gt; {        if (&#39;data&#39; in obj) {            // 遍历所有服务            obj[&#39;data&#39;].forEach(item =&gt; {                // 找到类型为NodePort的服务                if (item[&#39;kind&#39;] == &#39;NodePort&#39; &amp;&amp; &#39;publicEndpoints&#39; in item) {                    item[&#39;publicEndpoints&#39;].forEach(endpoint =&gt; {                        var service = endpoint                        service[&#39;name&#39;] = item[&#39;name&#39;]                        service[&#39;namespace&#39;] = item[&#39;namespaceId&#39;]                        services.push(service)                    })                }            });        }        // HTTP请求返回数据        res.send(services)    }).catch((e) =&gt; {        // HTTP请求返回数据        res.send(services)    })})// 注册UPnP设备描述文件访问路径app.get(&#39;/device.xml&#39;, (req, res) =&gt; {    res.contentType(&#39;text/xml&#39;)    // 从文件中读取    var xml = fs.readFileSync(&#39;./device.xml&#39;, &#39;utf8&#39;).toString()    // 替换主机名    xml = xml.replace(&#39;{hostname}&#39;, os.hostname()).replace(&#39;{hostname}&#39;, os.hostname())    // HTTP请求返回数据    res.send(xml)})app.get(&#39;/upnp-action.xml&#39;, (req, res) =&gt; {    res.contentType(&#39;text/xml&#39;)    var xml = fs.readFileSync(&#39;./upnp-action.xml&#39;, &#39;utf8&#39;).toString()    res.send(xml)})app.get(&#39;/icon.png&#39;, (req, res) =&gt; {    res.contentType(&#39;image/png&#39;)    res.sendfile(&#39;./icon.png&#39;)})app.post(&#39;/upnp-action&#39;, (req, res) =&gt; {    res.contentType(&#39;text/xml&#39;)    var xml = fs.readFileSync(&#39;./nodeport.xml&#39;, &#39;utf8&#39;).toString()    var services = []    rp({        uri: &#39;https://devops.zuozishi.info:6443/v3/project/c-cx29q:p-2hlhh/services/&#39;,        headers: {            &#39;Authorization&#39;: &#39;Bearer token-scvtk:&lt;token&gt;&#39;        },        json: true    }).then((obj) =&gt; {        if (&#39;data&#39; in obj) {            obj[&#39;data&#39;].forEach(item =&gt; {                if (item[&#39;kind&#39;] == &#39;NodePort&#39; &amp;&amp; &#39;publicEndpoints&#39; in item) {                    item[&#39;publicEndpoints&#39;].forEach(endpoint =&gt; {                        var service = endpoint                        service[&#39;name&#39;] = item[&#39;name&#39;]                        service[&#39;namespace&#39;] = item[&#39;namespaceId&#39;]                        services.push(service)                    })                }            });        }        xml = xml.replace(&#39;{data}&#39;,JSON.stringify(services))        res.send(xml)    }).catch((e) =&gt; {        xml = xml.xml(&#39;{data}&#39;, JSON.stringify(services))        res.send(services)    })})app.listen(port, () =&gt; { })</code></pre><ul><li>UPnP设备描述文件（device.xml）</li></ul><pre><code class="xml">&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot; configId=&quot;1337&quot;&gt;    &lt;specVersion&gt;        &lt;major&gt;1&lt;/major&gt;        &lt;minor&gt;1&lt;/minor&gt;    &lt;/specVersion&gt;    &lt;device&gt;        &lt;deviceType&gt;urn:schemas-upnp-org:device:EdgeGateway:1&lt;/deviceType&gt;        &lt;friendlyName&gt;边缘网关({hostname})&lt;/friendlyName&gt;        &lt;manufacturer&gt;分布式边缘计算网关&lt;/manufacturer&gt;        &lt;manufacturerURL&gt;https://devops.zuozishi.info:6443/&lt;/manufacturerURL&gt;        &lt;modelDescription&gt;分布式边缘计算网关&lt;/modelDescription&gt;        &lt;modelName&gt;{hostname}&lt;/modelName&gt;        &lt;modelNumber&gt;1.0&lt;/modelNumber&gt;        &lt;UDN&gt;uuid:f40c2981-7329-40b7-8b04-27f187aecfb5&lt;/UDN&gt;        &lt;modelURL&gt;https://devops.zuozishi.info:6443/&lt;/modelURL&gt;        &lt;presentationURL&gt;https://devops.zuozishi.info:6443/&lt;/presentationURL&gt;        &lt;iconList&gt;            &lt;icon&gt;                &lt;mimetype&gt;image/png&lt;/mimetype&gt;                &lt;width&gt;200&lt;/width&gt;                &lt;height&gt;200&lt;/height&gt;                &lt;depth&gt;24&lt;/depth&gt;                &lt;url&gt;icon.png&lt;/url&gt;            &lt;/icon&gt;        &lt;/iconList&gt;        &lt;serviceList&gt;            &lt;service&gt;                &lt;serviceType&gt;urn:schemas-upnp-org:service:k3s-nodePort-Service:1&lt;/serviceType&gt;                &lt;serviceId&gt;urn:schemas-upnp-org:serviceId:k3s-nodePort-Service1&lt;/serviceId&gt;                &lt;SCPDURL&gt;upnp-action.xml&lt;/SCPDURL&gt;                &lt;controlURL&gt;upnp-action&lt;/controlURL&gt;            &lt;/service&gt;        &lt;/serviceList&gt;    &lt;/device&gt;&lt;/root&gt;</code></pre><h3 id="6-3-Kubernets重要组件声明"><a href="#6-3-Kubernets重要组件声明" class="headerlink" title="6.3 Kubernets重要组件声明"></a>6.3 Kubernets重要组件声明</h3><ul><li>nfs-pv（可持续存储：NFS）</li></ul><pre><code class="yaml">apiVersion: v1kind: PersistentVolumemetadata:  name: nfs-pvspec:  capacity:    # 总空间    storage: 10Gi  accessModes:    # 支持多机读写    - ReadWriteMany  # 回收机制：不清除数据  persistentVolumeReclaimPolicy: Retain  storageClassName: nfs  nfs:    # 挂载路径    path: /nfsroot    # NFS服务器IP    server: 172.17.81.0---apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: nfs-pvcspec:  accessModes:    # 支持多机读写    - ReadWriteMany  resources:    requests:      # 单Pod使用空间      storage: 1Gi  storageClassName: nfs</code></pre><ul><li>aliyun-secret（阿里云密钥，用于DDNS域名解析）</li></ul><pre><code class="yaml">apiVersion: v1kind: Secretmetadata:  name: aliyun-secrettype: Opaquedata:  id: &lt;id&gt;  key: &lt;key&gt;</code></pre><ul><li>aliyun-docker-secret（阿里云镜像密钥，用于拉取私有镜像）</li></ul><pre><code class="yaml">kind: SecretapiVersion: v1metadata:  name: aliyun-docker-secret  namespace: defaultdata:  .dockerconfigjson: &gt;-    &lt;base64 data&gt;type: kubernetes.io/dockerconfigjson</code></pre><h3 id="6-4-k8s和k3s应用声明文件"><a href="#6-4-k8s和k3s应用声明文件" class="headerlink" title="6.4 k8s和k3s应用声明文件"></a>6.4 k8s和k3s应用声明文件</h3><ul><li>Aliyun-DDNS</li></ul><pre><code class="yaml"># 每个节点都部署kind: DaemonSetapiVersion: apps/v1metadata:  name: aliyun-ddns  labels:    app: aliyun-ddnsspec:  selector:    matchLabels:      app: aliyun-ddns  # 更新机制：滚动更新  updateStrategy:    type: RollingUpdate  template:    metadata:      labels:        app: aliyun-ddns    spec:      containers:        - name: aliyun-ddns          # 应用镜像          image: registry.cn-beijing.aliyuncs.com/zuozishi/aliyun-ddns:{ver}          env:            # 将密钥映射到环境变量            - name: ALIYUN_KEYID              valueFrom:                secretKeyRef:                  name: aliyun-secret                  key: id            # 将密钥映射到环境变量            - name: ALIYUN_SECRET              valueFrom:                secretKeyRef:                  name: aliyun-secret                  key: key            # 要解析的域名            - name: ALIYUN_DOMAIN              value: zuozishi.online          # 映射宿主机的主机名          volumeMounts:            - mountPath: /etc/hostname              name: hostname              readOnly: true      # 使用密钥拉取镜像      imagePullSecrets:        - name: aliyun-docker-secret      # 使用宿主机的文件      volumes:        - hostPath:            path: /etc/hostname          name: hostname</code></pre><ul><li>音乐播放服务（云端）</li></ul><pre><code class="yaml"># 应用声明apiVersion: apps/v1# 全自动调度kind: Deploymentmetadata:  name: music-cloud  labels:    app: music-cloudspec:  # 同时工作的副本数量  replicas: 1  selector:    matchLabels:      app: music-cloud  template:    metadata:      labels:        app: music-cloud    spec:      containers:        - name: music-cloud          # 应用镜像          image: registry.cn-beijing.aliyuncs.com/zuozishi/music-cloud:{ver}          # 每次运行时重新拉取镜像          imagePullPolicy: Always          ports:            # 声明外部端口号            - containerPort: 81              protocol: TCP          # 挂载NFS存储          volumeMounts:            - name: data              mountPath: /nfs-pvc      volumes:        - name: data          persistentVolumeClaim:            claimName: nfs-pvc      imagePullSecrets:        - name: aliyun-docker-secret---# 服务声明apiVersion: v1kind: Servicemetadata:  name: music-cloudspec:  # 将容器内81端口映射到宿主机30005端口  type: NodePort  ports:    - port: 81      nodePort: 30005  selector:    app: music-cloud</code></pre><h3 id="6-5-frp服务配置"><a href="#6-5-frp服务配置" class="headerlink" title="6.5 frp服务配置"></a>6.5 frp服务配置</h3><ul><li>服务端配置</li></ul><pre><code class="ini">[common]# 服务绑定端口bind_port = 7000# 开启密码认证authenticate_heartbeats = trueauthenticate_new_work_conns = trueauthentication_method = token# 密码token = www.123123# 控制面板绑定端口dashboard_port = 7500# 控制面板用户名dashboard_user = admin# 控制面板密码dashboard_pwd = www.123123</code></pre><ul><li>客户端配置<pre><code class="ini">[common]# 服务器IPserver_addr = 47.94.90.203# 服务器端口号server_port = 7000# 开启密码认证authenticate_heartbeats = trueauthenticate_new_work_conns = trueauthentication_method = token# 密码token = www.123123</code></pre></li></ul><h1 id="将本地30005端口映射到远程81端口"><a href="#将本地30005端口映射到远程81端口" class="headerlink" title="将本地30005端口映射到远程81端口"></a>将本地30005端口映射到远程81端口</h1><p>[MusicCloud]<br>type = tcp<br>local_ip = 127.0.0.1<br>local_port = 30005<br>remote_port = 81</p><pre><code>### 6.6 Azure Pipelines配置* AliyunDDNS```yaml# 提交master分支时触发trigger:- masterresources:- repo: selfstages:- stage: AutoDeploy  displayName: 自动化部署  pool:    vmImage: &#39;ubuntu-latest&#39;  jobs:    - job: AutoDeploy    displayName: 自动化部署    steps:    - task: Bash@3      displayName: 编译镜像      inputs:        targetType: &#39;inline&#39;        script: &#39;docker build -t registry.cn-beijing.aliyuncs.com/zuozishi/aliyun-ddns:`cat version` .&#39;    - task: Docker@2      displayName: 登录阿里云镜像仓库      inputs:        containerRegistry: &#39;阿里云镜像仓库&#39;        command: &#39;login&#39;    - task: Bash@3      displayName: 推送镜像      inputs:        targetType: &#39;inline&#39;        script: |          docker images          docker push registry.cn-beijing.aliyuncs.com/zuozishi/aliyun-ddns:`cat version`    - task: Bash@3      displayName: 配置应用清单      inputs:        targetType: &#39;inline&#39;        script: |          sed -i &quot;s/{ver}/`cat version`/&quot; aliyunddns.yaml    - task: CopyFilesOverSSH@0      displayName: 上传应用清单      inputs:          sshEndpoint: &#39;k3s-master&#39;          sourceFolder: ./          contents: &#39;aliyunddns.yaml&#39;          targetFolder: /tmp/    - task: SSH@0      displayName: &#39;部署应用&#39;      inputs:        sshEndpoint: &#39;k3s-master&#39;        commands: &#39;k3s kubectl apply -f /tmp/aliyunddns.yaml --force&#39;</code></pre><ul><li>音乐播放服务</li></ul><pre><code class="yaml">trigger:- masterresources:- repo: selfstages:- stage: AutoDeploy  displayName: 自动化部署  pool:    vmImage: &#39;ubuntu-latest&#39;  jobs:    - job: AutoDeploy    displayName: 自动化部署    steps:    - task: Bash@3      displayName: 编译镜像      inputs:        targetType: &#39;inline&#39;        script: &#39;docker build -t registry.cn-beijing.aliyuncs.com/zuozishi/music-cloud:`cat version` .&#39;    - task: Docker@2      displayName: 登录阿里云镜像仓库      inputs:        containerRegistry: &#39;阿里云镜像仓库&#39;        command: &#39;login&#39;    - task: Bash@3      displayName: 推送镜像      inputs:        targetType: &#39;inline&#39;        script: |          docker images          docker push registry.cn-beijing.aliyuncs.com/zuozishi/music-cloud:`cat version`    - task: Bash@3      displayName: 配置应用清单      inputs:        targetType: &#39;inline&#39;        script: |          sed -i &quot;s/{ver}/`cat version`/&quot; kubernetes.k8s.yaml          sed -i &quot;s/{ver}/`cat version`/&quot; kubernetes.k3s.yaml    - task: CopyFilesOverSSH@0      displayName: 上传应用清单（k8s）      inputs:          sshEndpoint: &#39;k8s-master&#39;          sourceFolder: ./          contents: &#39;kubernetes.k8s.yaml&#39;          targetFolder: /tmp/    - task: SSH@0      displayName: &#39;部署应用（k8s）&#39;      inputs:        sshEndpoint: &#39;k8s-master&#39;        commands: &#39;kubectl apply -f /tmp/kubernetes.k8s.yaml --force&#39;    - task: CopyFilesOverSSH@0      displayName: 上传应用清单（k3s）      inputs:          sshEndpoint: &#39;k3s-master&#39;          sourceFolder: ./          contents: &#39;kubernetes.k3s.yaml&#39;          targetFolder: /tmp/    - task: SSH@0      displayName: &#39;部署应用（k3s）&#39;      inputs:        sshEndpoint: &#39;k3s-master&#39;        commands: &#39;k3s kubectl apply -f /tmp/kubernetes.k3s.yaml --force&#39;</code></pre><h2 id="7-成果展示及改进"><a href="#7-成果展示及改进" class="headerlink" title="7 成果展示及改进"></a>7 成果展示及改进</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="附录-A：项目开源说明"><a href="#附录-A：项目开源说明" class="headerlink" title="附录 A：项目开源说明"></a>附录 A：项目开源说明</h3><p><strong>AliyunDDNS</strong><br>Source: <a href="https://dev.azure.com/zuozishi/AliyunDDNS" target="_blank" rel="noopener">https://dev.azure.com/zuozishi/AliyunDDNS</a><br>License: MIT</p><p><strong>MusicCloud</strong><br>Source: <a href="https://dev.azure.com/zuozishi/MusicCloud" target="_blank" rel="noopener">https://dev.azure.com/zuozishi/MusicCloud</a><br>License: MIT</p><p><strong>cloud_music</strong><br>Source: <a href="https://dev.azure.com/zuozishi/cloud_music" target="_blank" rel="noopener">https://dev.azure.com/zuozishi/cloud_music</a><br>License: MIT</p><p><strong>RaspberrypiController</strong><br>Source: <a href="https://dev.azure.com/zuozishi/RaspberrypiController" target="_blank" rel="noopener">https://dev.azure.com/zuozishi/RaspberrypiController</a><br>License: MIT</p><p><strong>ProjectEdgeDoc</strong><br>Source: <a href="https://github.com/zuozishi/ProjectEdgeDoc" target="_blank" rel="noopener">https://github.com/zuozishi/ProjectEdgeDoc</a></p><h3 id="附录-B：第三方软件说明（Third-Party-Notices）"><a href="#附录-B：第三方软件说明（Third-Party-Notices）" class="headerlink" title="附录 B：第三方软件说明（Third Party Notices）"></a>附录 B：第三方软件说明（Third Party Notices）</h3><p>Notwithstanding any other terms, you may reverse engineer this software to the extent required to debug changes to any libraries licensed under the GNU Lesser General Public License.</p><p><strong>Kubernetes</strong><br>Source: <a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes</a><br>License: Apache-2.0</p><p><strong>k3s</strong><br>Source: <a href="https://github.com/rancher/k3s/" target="_blank" rel="noopener">https://github.com/rancher/k3s/</a><br>License: Apache-2.0</p><p><strong>node-ssdp</strong><br>Source: <a href="https://github.com/diversario/node-ssdp" target="_blank" rel="noopener">https://github.com/diversario/node-ssdp</a><br>License: MIT</p><p><strong>express</strong><br>Source: <a href="https://github.com/expressjs/express" target="_blank" rel="noopener">https://github.com/expressjs/express</a><br>License: MIT</p><p><strong>request</strong><br>Source: <a href="https://github.com/request/request" target="_blank" rel="noopener">https://github.com/request/request</a><br>License: Apache-2.0</p><p><strong>request-promise</strong><br>Source: <a href="https://github.com/request/request-promise" target="_blank" rel="noopener">https://github.com/request/request-promise</a><br>License: ISC</p><p><strong>request-promise</strong><br>Source: <a href="https://github.com/nashwaan/xml-js" target="_blank" rel="noopener">https://github.com/nashwaan/xml-js</a><br>License: MIT</p><p><strong>SSDP.Portable</strong><br>Source: <a href="https://github.com/kakone/SSDP" target="_blank" rel="noopener">https://github.com/kakone/SSDP</a><br>License: GPL-2.0</p><p><strong>.NET Core IoT Libraries</strong><br>Source: <a href="https://github.com/dotnet/iot" target="_blank" rel="noopener">https://github.com/dotnet/iot</a><br>License: MIT</p><p><strong>Microsoft.AspNetCore.SignalR.Client</strong><br>Source: <a href="https://github.com/aspnet/AspNetCore" target="_blank" rel="noopener">https://github.com/aspnet/AspNetCore</a><br>License: Apache-2.0</p><p><strong>HtmlAgilityPack</strong><br>Source: <a href="https://github.com/zzzprojects/html-agility-pack/" target="_blank" rel="noopener">https://github.com/zzzprojects/html-agility-pack/</a><br>License: MIT</p><p><strong>Newtonsoft.Json</strong><br>Source: <a href="https://github.com/JamesNK/Newtonsoft.Json" target="_blank" rel="noopener">https://github.com/JamesNK/Newtonsoft.Json</a><br>License: MIT</p><p><strong>signalr_client</strong><br>Source: <a href="https://github.com/soernt/signalr_client" target="_blank" rel="noopener">https://github.com/soernt/signalr_client</a><br>License: MIT</p><p><strong>audioplayers</strong><br>Source: <a href="https://github.com/luanpotter/audioplayer" target="_blank" rel="noopener">https://github.com/luanpotter/audioplayer</a><br>License: MIT</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化/容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> ProjectEdge </tag>
            
            <tag> Docker </tag>
            
            <tag> k3s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s集群中的坑</title>
      <link href="/2020/04/21/ProjectEdge/k8s%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%9D%91/"/>
      <url>/2020/04/21/ProjectEdge/k8s%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="无法访问上游DNS服务器"><a href="#无法访问上游DNS服务器" class="headerlink" title="无法访问上游DNS服务器"></a>无法访问上游DNS服务器</h2><p>修改<code>kube-system</code>命名空间的Config Map:<code>coredns</code></p><pre><code class="yaml">kind: ConfigMapapiVersion: v1metadata:  name: coredns  namespace: kube-system  selfLink: ...  uid: ...  resourceVersion: ...  creationTimestamp: ...data:  Corefile: |    .:53 {        errors        ready        health        forward . 114.114.114.114        kubernetes cluster.local in-addr.arpa ip6.arpa {          pods insecure        }        cache 30        reload        loadbalance    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 虚拟化/容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> ProjectEdge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu/CentOS搭建NFS服务</title>
      <link href="/2020/04/16/linux/Ubuntu%20CentOS%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/"/>
      <url>/2020/04/16/linux/Ubuntu%20CentOS%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="1、NFS-介绍"><a href="#1、NFS-介绍" class="headerlink" title="1、NFS 介绍"></a>1、NFS 介绍</h2><p>NFS 即网络文件系统（Network File-System），可以通过网络让不同机器、不同系统之间可以实现文件共享。通过 NFS，可以访问远程共享目录，就像访问本地磁盘一样。NFS 只是一种文件系统，本身并没有传输功能，是基于 RPC（远程过程调用）协议实现的，采用 C/S 架构。</p><h2 id="2、安装-NFS-软件包"><a href="#2、安装-NFS-软件包" class="headerlink" title="2、安装 NFS 软件包"></a>2、安装 NFS 软件包</h2><p>Ubuntu：</p><pre><code class="bash">apt-get install nfs-kernel-server  # 安装 NFS服务器端apt-get install nfs-common rpcbind # 安装 NFS客户端</code></pre><p>CentOS：</p><pre><code class="bash">yum install -y nfs-common nfs-utils rpcbind</code></pre><h2 id="3、添加-NFS-共享目录"><a href="#3、添加-NFS-共享目录" class="headerlink" title="3、添加 NFS 共享目录"></a>3、添加 NFS 共享目录</h2><p>若需要把 <code>/nfsroot</code> 目录设置为 NFS 共享目录，请在<code>/etc/export</code>文件末尾添加下面的一行：</p><p><code>/nfsroot *(rw,no_root_squash,no_all_squash,sync) # * 表示允许任何网段 IP 的系统访问该 NFS 目录</code></p><p>新建<code>/nfsroot</code>目录，并为该目录设置最宽松的权限：</p><pre><code class="bash">mkdir /nfsrootchmod 777 /nfsroot</code></pre><h2 id="4、启动-NFS-服务"><a href="#4、启动-NFS-服务" class="headerlink" title="4、启动 NFS 服务"></a>4、启动 NFS 服务</h2><p><code>/etc/init.d/nfs-kernel-server start</code></p><p>在 NFS 服务已经启动的情况下，如果修改了 <code>/etc/exports</code> 文件，需要重启 NFS 服务，以刷新 NFS 的共享目录。</p><p><code>/etc/init.d/nfs-kernel-server restart</code></p><h2 id="5、测试-NFS-服务器"><a href="#5、测试-NFS-服务器" class="headerlink" title="5、测试 NFS 服务器"></a>5、测试 NFS 服务器</h2><p><code>sudo mount -t nfs &lt;ip_addr&gt;:/nfsroot /mnt -o nolock</code></p><p><code>&lt;ip_addr&gt;</code>为主机 ip，<code>/nfsroot</code>为主机共享目录，<code>/mnt</code> 为设备挂载目录，如果指令运行没有出错，则 NFS 挂载成功，在主机的<code>/mnt</code> 目录下应该可以看到<code>/nfsroot</code>目录下的内容（可先在 nfsroot 目录下新建测试目录），如需卸载使用</p><p><code>umount /mnt</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下搭建GitLab</title>
      <link href="/2020/04/16/linux/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BAgitlab/"/>
      <url>/2020/04/16/linux/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BAgitlab/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h2><p><code>sudo apt-get install -y curl openssh-server ca-certificates</code></p><p>安装Postfix服务用来发送通知邮件，使用其他SMTP服务器可以跳过此步。</p><p><code>sudo apt-get install -y postfix</code></p><h2 id="2-安装GitLab"><a href="#2-安装GitLab" class="headerlink" title="2. 安装GitLab"></a>2. 安装GitLab</h2><p>添加镜像源：</p><pre><code class="bash">curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/nullecho &quot;deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu bionic main&quot; &gt; /etc/apt/sources.list.d/gitlab-ce.listsudo apt-get update</code></pre><p>安装GitLab：</p><p><code>sudo EXTERNAL_URL=&quot;https://gitlab.example.com&quot; apt-get install gitlab-ce</code></p><p>将<code>https://gitlab.example.com</code>替换为自己的链接，GitLab将自动从<a href="https://docs.gitlab.com/omnibus/settings/ssl.html#lets-encrypthttpsletsencryptorg-integration" target="_blank" rel="noopener">Let’s Encrypt</a>获取证书。</p><h2 id="3-浏览器访问"><a href="#3-浏览器访问" class="headerlink" title="3. 浏览器访问"></a>3. 浏览器访问</h2><p>第一次访问时，将提示重置密码，默认账户名为<code>root</code>。</p><h2 id="4-管理工具：gitlab-ctl"><a href="#4-管理工具：gitlab-ctl" class="headerlink" title="4. 管理工具：gitlab-ctl"></a>4. 管理工具：gitlab-ctl</h2><p>启动/停止/重启/强制停止/状态</p><p><code>gitlab-ctl start/stop/restart/kill/status</code></p><p>重新获取HTTPS证书</p><p><code>gitlab-ctl renew-le-certs</code></p><p>清除所有数据</p><p><code>gitlab-ctl cleanse</code></p><p>卸载</p><p><code>gitlab-ctl uninstall</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装k8s集群</title>
      <link href="/2020/04/16/ProjectEdge/%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/04/16/ProjectEdge/%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="一、关闭防火墙"><a href="#一、关闭防火墙" class="headerlink" title="一、关闭防火墙"></a>一、关闭防火墙</h2><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><pre><code class="bash">systemctl stop firewalldsystemctl disable firewalldsystemctl status firewalld</code></pre><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><pre><code class="bash">ufw disable</code></pre><h2 id="二、配置apt-yum源（云主机可跳过此步）"><a href="#二、配置apt-yum源（云主机可跳过此步）" class="headerlink" title="二、配置apt/yum源（云主机可跳过此步）"></a>二、配置apt/yum源（云主机可跳过此步）</h2><h3 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h3><pre><code class="bash">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum makecachesetenforce 0</code></pre><h3 id="CentOS-8"><a href="#CentOS-8" class="headerlink" title="CentOS 8"></a>CentOS 8</h3><pre><code class="bash">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repoyum makecachesetenforce 0</code></pre><h3 id="Ubuntu-16-04"><a href="#Ubuntu-16-04" class="headerlink" title="Ubuntu 16.04"></a>Ubuntu 16.04</h3><pre><code class="bash">cat &lt;&lt; EOF &gt; /etc/apt/sources.listdeb http://mirrors.aliyun.com/ubuntu/ xenial maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial maindeb http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universeEOFsudo apt update</code></pre><h3 id="Ubuntu-18-04"><a href="#Ubuntu-18-04" class="headerlink" title="Ubuntu 18.04"></a>Ubuntu 18.04</h3><pre><code class="bash">cat &lt;&lt; EOF &gt; /etc/apt/sources.listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverseEOFsudo apt update</code></pre><h2 id="三、安装kubernetes部署工具"><a href="#三、安装kubernetes部署工具" class="headerlink" title="三、安装kubernetes部署工具"></a>三、安装kubernetes部署工具</h2><h3 id="CentOS-1"><a href="#CentOS-1" class="headerlink" title="CentOS"></a>CentOS</h3><pre><code class="bash">curl http://mirrors.cloud.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo &gt; /etc/yum.repos.d/docker-ce.repocat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFyum install net-tools sshpass docker-ce docker-ce-cli containerd.io kubelet kubeadm kubectl --nogpgcheck -y</code></pre><h3 id="Ubuntu-1"><a href="#Ubuntu-1" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><pre><code class="bash">apt-get update &amp;&amp; apt-get install -y install apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOFapt install net-tools sshpass docker-ce docker-ce-cli containerd.io kubelet kubeadm kubectl -y</code></pre><h2 id="四、配置Docker镜像源"><a href="#四、配置Docker镜像源" class="headerlink" title="四、配置Docker镜像源"></a>四、配置Docker镜像源</h2><pre><code class="bash">echo &#39;{&quot;registry-mirrors&quot;: [&quot;https://3m7egqv1.mirror.aliyuncs.com&quot;]}&#39; &gt; /etc/docker/daemon.jsonsystemctl daemon-reloadsystemctl restart docker</code></pre><h2 id="五、配置系统"><a href="#五、配置系统" class="headerlink" title="五、配置系统"></a>五、配置系统</h2><pre><code class="bash">setenforce 0# 重置路由表iptables -P FORWARD ACCEPTecho 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptablesecho 1 &gt; /proc/sys/net/bridge/bridge-nf-call-ip6tables# 关闭交换分区swapoff -a# 还要修改/etc/fstab文件注释掉swap分区</code></pre><h2 id="六、配置k8s"><a href="#六、配置k8s" class="headerlink" title="六、配置k8s"></a>六、配置k8s</h2><pre><code class="yaml"># init-config.yamlapiVersion: kubeadm.k8s.io/v1beta2kind: ClusterConfigurationimageRepository: gcr.azk8s.cn/google_containerskubernetesVersion: v1.17.0networking:  podSubnet: &quot;172.16.0.0/16&quot;</code></pre><pre><code class="bash"># 下载所需镜像kubeadm config images pull --config=init-config.yaml# 初始化kuberneteskubeadm init --config=init-config.yaml --ignore-preflight-errors=NumCPU# 配置kubectlmkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config# 配置kubernetes网络kubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &#39;\n&#39;)&quot;# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# 设置master为可执行node节点（可选）kubectl taint nodes --all node-role.kubernetes.io/master-# 配置ApiServer SSL证书grep &#39;client-certificate-data&#39; ~/.kube/config | head -n 1 | awk &#39;{print $2}&#39; | base64 -d &gt; kubecfg.crtgrep &#39;client-key-data&#39; ~/.kube/config | head -n 1 | awk &#39;{print $2}&#39; | base64 -d &gt; kubecfg.keyopenssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name &quot;kubernetes-client&quot;</code></pre><h2 id="七、安装k8s-Dashboard"><a href="#七、安装k8s-Dashboard" class="headerlink" title="七、安装k8s Dashboard"></a>七、安装k8s Dashboard</h2><pre><code class="bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yamlkubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &#39;{print $1}&#39;) &gt; token.txt</code></pre><p>客户端安装CA证书</p><p>浏览器访问：https://&lt;master-ip&gt;:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化/容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> ProjectEdge </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mermaid图表</title>
      <link href="/2020/04/16/mermaid/"/>
      <url>/2020/04/16/mermaid/</url>
      
        <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><ol><li><p>安装hexo插件</p><pre><code class="bash">npm install hexo-filter-mermaid-diagrams</code></pre></li><li><p>修改<code>themes/3-hexo/_config.yml</code> 的 <code>mermaid.on</code>，开启主题支持</p><pre><code class="yml"># Mermaid 支持mermaid:on: truecdn: //cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js#cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.3.1/mermaid.min.jsoptions: # 更多配置信息可以参考 https://mermaidjs.github.io/#/mermaidAPI theme: &#39;default&#39; startOnLoad: true flowchart:   useMaxWidth: false   htmlLabels: true</code></pre></li><li><p>在markdown中，像写代码块一样写图表<br><img src="//img.saodiyang.com/FuBTJvG5xIOIcKZPnO9UX5GCwthK.png" alt=""></p></li></ol><h2 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h2><p>以下示例源码可以在这边查看 <a href="https://github.com/yelog/blog/blob/master/source/_posts/tools/3-hexo%E6%94%AF%E6%8C%81mermaid%E5%9B%BE%E8%A1%A8.md" target="_blank" rel="noopener">本文源码</a><br>更多示例可以查看官网：<a href="https://mermaidjs.github.io" target="_blank" rel="noopener">https://mermaidjs.github.io</a></p><h3 id="1-flowchart"><a href="#1-flowchart" class="headerlink" title="1. flowchart"></a>1. flowchart</h3><pre class="mermaid">graph TD;    A-->B;    A-->C;    B-->D;    C-->D;</pre><pre class="mermaid">graph TB    c1-->a2    subgraph one    a1-->a2    end    subgraph two    b1-->b2    end    subgraph three    c1-->c2    end</pre><h3 id="2-Sequence-diagrams"><a href="#2-Sequence-diagrams" class="headerlink" title="2.Sequence diagrams"></a>2.Sequence diagrams</h3><pre class="mermaid">sequenceDiagram    participant Alice    participant Bob    Alice->>John: Hello John, how are you?    loop Healthcheck        John->>John: Fight against hypochondria    end    Note right of John: Rational thoughts <br/>prevail!    John-->>Alice: Great!    John->>Bob: How about you?    Bob-->>John: Jolly good!</pre><h3 id="3-Class-diagrams"><a href="#3-Class-diagrams" class="headerlink" title="3.Class diagrams"></a>3.Class diagrams</h3><pre class="mermaid">classDiagram     Animal <|-- Duck     Animal <|-- Fish     Animal <|-- Zebra     Animal : +int age     Animal : +String gender     Animal: +isMammal()     Animal: +mate()     class Duck{         +String beakColor         +swim()         +quack()     }     class Fish{         -int sizeInFeet         -canEat()     }     class Zebra{         +bool is_wild         +run()     }</pre><h3 id="4-State-diagrams"><a href="#4-State-diagrams" class="headerlink" title="4.State diagrams"></a>4.State diagrams</h3><pre class="mermaid">stateDiagram       [*] --> Active       state Active {           [*] --> NumLockOff           NumLockOff --> NumLockOn : EvNumLockPressed           NumLockOn --> NumLockOff : EvNumLockPressed           --           [*] --> CapsLockOff           CapsLockOff --> CapsLockOn : EvCapsLockPressed           CapsLockOn --> CapsLockOff : EvCapsLockPressed           --           [*] --> ScrollLockOff           ScrollLockOff --> ScrollLockOn : EvCapsLockPressed           ScrollLockOn --> ScrollLockOff : EvCapsLockPressed       }</pre><h3 id="5-Gantt-diagrams"><a href="#5-Gantt-diagrams" class="headerlink" title="5.Gantt diagrams"></a>5.Gantt diagrams</h3><pre class="mermaid">gantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h</pre><h3 id="6-Pie-chart-diagrams"><a href="#6-Pie-chart-diagrams" class="headerlink" title="6.Pie chart diagrams"></a>6.Pie chart diagrams</h3><pre class="mermaid">pie    "Dogs" : 386    "Cats" : 85    "Rats" : 15</pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2020/04/16/tools/Markdown/"/>
      <url>/2020/04/16/tools/Markdown/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><p>示例：</p><pre><code class="Markdown"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><p>效果如下：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><p><strong>加粗</strong></p><p>要加粗的文字左右分别用两个*号包起来</p><p><em>斜体</em></p><p>要倾斜的文字左右分别用一个*号包起来</p><p><strong><em>斜体加粗</em></strong></p><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><p><del>删除线</del></p><p>要加删除线的文字左右分别用两个~~号包起来</p><p>示例：</p><pre><code class="Markdown">**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~</code></pre><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用</p><p>示例：</p><pre><code class="Markdown">&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容</code></pre><p>效果如下：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote><h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><pre><code class="Markdown">-------********</code></pre><p>效果如下：<br>可以看到，显示效果是一样的。</p><hr><hr><hr><hr><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>语法：</p><pre><code class="Markdown">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</code></pre><p>示例：</p><pre><code class="Markdown">![zuozishi](https://avatars1.githubusercontent.com/u/20531439 &quot;Zuozishi&quot;)</code></pre><p>效果如下：</p><p><img src="https://avatars1.githubusercontent.com/u/20531439" alt="zuozishi" title="Zuozishi"></p><h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>语法：</p><pre><code class="Markdown">[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加</code></pre><p>示例：</p><pre><code class="Markdown">[简书](http://jianshu.com)[百度](http://baidu.com)</code></pre><p>效果如下：<br><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>语法：<br>无序列表用 - + * 任何一种都可以</p><pre><code class="Markdown">- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格</code></pre><p>效果如下：</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>语法：<br>数字加点</p><pre><code class="Markdown">1. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格</code></pre><p>效果如下：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p><strong>上一级和下一级之间敲三个空格即可</strong></p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ul><ol><li><p>一级有序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级有序列表内容</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ol><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>语法：</p><pre><code class="Markdown">表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略</code></pre><p>示例：</p><pre><code class="Markdown">姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟</code></pre><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h2 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h2><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><pre><code class="Markdown">    `代码内容`</code></pre><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><pre><code class="Markdown">(```)  代码...  代码...  代码...(```)</code></pre><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell速查表</title>
      <link href="/2018/09/08/shell-command/"/>
      <url>/2018/09/08/shell-command/</url>
      
        <content type="html"><![CDATA[<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><pre><code class="bash">#!/bin/bashmsg=&quot;hello world&quot;echo $msg</code></pre><blockquote><p><strong>变量名的命名须遵循如下规则：</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul></blockquote><h2 id="2-传参"><a href="#2-传参" class="headerlink" title="2. 传参"></a>2. 传参</h2><pre><code class="bash">#!/bin/bashecho &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;</code></pre><blockquote><p><strong>脚本内获取参数的格式为：</strong><br>$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……<br><strong>另外，还有几个特殊字符用来处理参数：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>传递到脚本的参数个数</td></tr><tr><td><code>$*</code></td><td>以一个单字符串显示所有向脚本传递的参数。<br>如<code>&quot;$*&quot;</code>用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td><code>$$</code></td><td>脚本运行的当前进程ID号</td></tr><tr><td><code>$!</code></td><td>后台运行的最后一个进程的ID号</td></tr><tr><td><code>$@</code></td><td>与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。<br>如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td><code>$-</code></td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td><code>$?</code></td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table></blockquote><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><pre><code class="bash">#!/bin/bashmy_array=(A B &quot;C&quot; D)echo &quot;第一个元素为: ${my_array[0]}&quot;echo &quot;第二个元素为: ${my_array[1]}&quot;echo &quot;第三个元素为: ${my_array[2]}&quot;echo &quot;第四个元素为: ${my_array[3]}&quot;echo &quot;数组的元素为: ${my_array[*]}&quot;echo &quot;数组的元素为: ${my_array[@]}&quot;echo &quot;数组元素个数为: ${#my_array[*]}&quot;echo &quot;数组元素个数为: ${#my_array[@]}&quot;</code></pre><p>执行结果如下：</p><pre><code class="yml">第一个元素为: A第二个元素为: B第三个元素为: C第四个元素为: D数组的元素为: A B C D数组的元素为: A B C D数组元素个数为: 4数组元素个数为: 4</code></pre><h2 id="4-基本运算符"><a href="#4-基本运算符" class="headerlink" title="4. 基本运算符"></a>4. 基本运算符</h2><blockquote><p>原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p></blockquote><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><h3 id="①-算数运算符"><a href="#①-算数运算符" class="headerlink" title="① 算数运算符"></a>① 算数运算符</h3><pre><code class="bash">#!/bin/bashecho &quot;2加2等于&quot;`expr 2 + 2`echo &quot;2减2等于&quot;`expr 2 - 2`echo &quot;2乘2等于&quot;`expr 2 \* 2`echo &quot;2除2等于&quot;`expr 2 / 2`echo &quot;2除2取余&quot;`expr 2 % 2`</code></pre><h3 id="②-关系运算符"><a href="#②-关系运算符" class="headerlink" title="② 关系运算符"></a>② 关系运算符</h3><pre><code class="bash">#!/bin/basha=10b=20if [ $a -eq $b ] # 检测两个数是否相等，相等返回 true。if [ $a -ne $b ] # 检测两个数是否不相等，不相等返回 true。if [ $a -gt $b ] # 检测左边的数是否大于右边的，如果是，则返回 true。if [ $a -lt $b ] # 检测左边的数是否小于右边的，如果是，则返回 true。if [ $a -ge $b ] # 检测左边的数是否大于等于右边的，如果是，则返回 true。if [ $a -le $b ] # 检测左边的数是否小于等于右边的，如果是，则返回 true。</code></pre><h3 id="③-布尔运算符"><a href="#③-布尔运算符" class="headerlink" title="③ 布尔运算符"></a>③ 布尔运算符</h3><pre><code class="bash">#!/bin/bashif [ ! false ]       # 非运算，返回 trueif [ true -o false ] # 或运算，返回 trueif [ true -a false ] # 与运算，返回 false</code></pre><h3 id="④-逻辑运算符"><a href="#④-逻辑运算符" class="headerlink" title="④ 逻辑运算符"></a>④ 逻辑运算符</h3><pre><code class="bash">#!/bin/basha=10b=20if [[ $a -lt $b &amp;&amp; $a -gt $b ]]   # 逻辑的 AND, 返回 falseif [ $a -lt $b ] &amp;&amp; [ $a -gt $b ] # 逻辑的 AND, 返回 falseif [[ $a -lt $b || $a -gt $b ]]   # 逻辑的 OR, 返回 trueif [ $a -lt $b ] || [ $a -gt $b ] # 逻辑的 OR, 返回 true</code></pre><h3 id="⑤-字符串运算符"><a href="#⑤-字符串运算符" class="headerlink" title="⑤ 字符串运算符"></a>⑤ 字符串运算符</h3><pre><code class="bash">#!/bin/basha=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]   # 检测两个字符串是否相等，相等返回 true。if [ $a != $b ]  # 检测两个字符串是否相等，不相等返回 true。if [ -z $a ]     # 检测字符串长度是否为0，为0返回 true。if [ -n &quot;$a&quot; ]   # 检测字符串长度是否为0，不为0返回 true。if [ $a ]        # 检测字符串是否为空，不为空返回 true。</code></pre><h3 id="⑥-文件测试运算符"><a href="#⑥-文件测试运算符" class="headerlink" title="⑥ 文件测试运算符"></a>⑥ 文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true。</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td></tr></tbody></table><h2 id="5-echo"><a href="#5-echo" class="headerlink" title="5. echo"></a>5. echo</h2><h3 id="①-命令格式"><a href="#①-命令格式" class="headerlink" title="① 命令格式"></a>① 命令格式</h3><pre><code class="bash">#!/bin/bashecho &quot;It is a test&quot;echo It is a testecho &quot;\&quot;It is a test\&quot;&quot;      # 转义name=Chrisecho &quot;$name is handsome&quot;echo -e &quot;OK! \n&quot;             # 显示换行 -e 开启转义echo &quot;It is a test&quot; &gt; myfile # 显示结果定向至文件echo &#39;$name\&quot;&#39;               # 原样输入字符串，不进行转义或取变量（使用单引号）echo `date`                  # 显示命令执行结构</code></pre><h3 id="②-颜色显示"><a href="#②-颜色显示" class="headerlink" title="② 颜色显示"></a>② 颜色显示</h3><pre><code class="bash">echo -e &quot;\033[字背景颜色；文字颜色m字符串\033[0m&quot;echo -e “\033[30m 黑色字 \033[0m”echo -e “\033[31m 红色字 \033[0m”echo -e “\033[32m 绿色字 \033[0m”echo -e “\033[33m 黄色字 \033[0m”echo -e “\033[34m 蓝色字 \033[0m”echo -e “\033[35m 紫色字 \033[0m”echo -e “\033[36m 天蓝字 \033[0m”echo -e “\033[37m 白色字 \033[0m”echo -e “\033[40;37m 黑底白字 \033[0m”echo -e “\033[41;37m 红底白字 \033[0m”echo -e “\033[42;37m 绿底白字 \033[0m”echo -e “\033[43;37m 黄底白字 \033[0m”echo -e “\033[44;37m 蓝底白字 \033[0m”echo -e “\033[45;37m 紫底白字 \033[0m”echo -e “\033[46;37m 天蓝底白字 \033[0m”echo -e “\033[47;30m 白底黑字 \033[0m”\33[0m 关闭所有属性\33[1m 设置高亮度\33[4m 下划线\33[5m 闪烁\33[7m 反显\33[8m 消隐\33[30m — \33[37m 设置前景色\33[40m — \33[47m 设置背景色\33[nA 光标上移n行\33[nB 光标下移n行\33[nC 光标右移n行\33[nD 光标左移n行\33[y;xH设置光标位置\33[2J 清屏\33[K 清除从光标到行尾的内容\33[s 保存光标位置\33[u 恢复光标位置\33[?25l 隐藏光标\33[?25h 显示光标</code></pre><h2 id="6-sprintf"><a href="#6-sprintf" class="headerlink" title="6. sprintf"></a>6. sprintf</h2><pre><code class="bash">#!/bin/bashprintf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</code></pre><p>结果：</p><pre><code>姓名     性别   体重kg郭靖     男      66.12杨过     男      48.65郭芙     女      47.99</code></pre><blockquote><p><code>%s %c %d %f</code> 都是格式替代符<br><code>d</code>: Decimal 十进制整数 – 对应位置参数必须是十进制整数，否则报错！<br><code>s</code>: String 字符串 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>c</code>: Char 字符 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>f</code>: Float 浮点 – 对应位置参数必须是数字型，否则报错！<br><code>%-10s</code> 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐）,任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br><code>%-4.2f</code> 指格式化为小数，其中.2指保留2位小数。</p></blockquote><h2 id="7-test"><a href="#7-test" class="headerlink" title="7. test"></a>7. test</h2><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><pre><code class="bash">#!/bin/bashnum1=100num2=100if test $[num1] -eq $[num2]</code></pre><h2 id="8-流程控制"><a href="#8-流程控制" class="headerlink" title="8. 流程控制"></a>8. 流程控制</h2><h3 id="①-if-else"><a href="#①-if-else" class="headerlink" title="① if-else"></a>① if-else</h3><pre><code class="bash">#!/bin/basha=10b=20if [ $a == $b ]then   echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then   echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then   echo &quot;a 小于 b&quot;else   echo &quot;没有符合的条件&quot;fi</code></pre><h3 id="②-for"><a href="#②-for" class="headerlink" title="② for"></a>② for</h3><pre><code class="bash">#!/bin/bashfor loop in 1 2 3 4 5do    echo &quot;The value is: $loop&quot;done</code></pre><h3 id="③-while"><a href="#③-while" class="headerlink" title="③ while"></a>③ while</h3><pre><code class="bash">#!/bin/bashint=1while(( $int&lt;=5 ))do    echo $int    let &quot;int++&quot;done</code></pre><h3 id="④-case"><a href="#④-case" class="headerlink" title="④ case"></a>④ case</h3><pre><code class="bash">#!/bin/bashecho &#39;输入 1 到 4 之间的数字:&#39;echo &#39;你输入的数字为:&#39;read aNumcase $aNum in    1)  echo &#39;你选择了 1&#39;    ;;    2)  echo &#39;你选择了 2&#39;    ;;    3)  echo &#39;你选择了 3&#39;    ;;    4)  echo &#39;你选择了 4&#39;    ;;    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;    ;;esac</code></pre><h3 id="⑤-break"><a href="#⑤-break" class="headerlink" title="⑤ break"></a>⑤ break</h3><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><pre><code class="bash">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字:&quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;            break        ;;    esacdone</code></pre><h3 id="⑥-continue"><a href="#⑥-continue" class="headerlink" title="⑥ continue"></a>⑥ continue</h3><p>跳出当前循环。</p><pre><code class="bash">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字: &quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;            continue            echo &quot;游戏结束&quot;        ;;    esacdone</code></pre><h3 id="⑦-until"><a href="#⑦-until" class="headerlink" title="⑦ until"></a>⑦ until</h3><pre><code class="bash">#!/bin/basha=0until [ ! $a -lt 10 ]do   echo $a   a=`expr $a + 1`done</code></pre><h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9. 函数"></a>9. 函数</h2><pre><code class="bash">#!/bin/bashfunWithParam(){    echo &quot;第一个参数为 $1 !&quot;    echo &quot;第二个参数为 $2 !&quot;    echo &quot;第十个参数为 $10 !&quot;    echo &quot;第十个参数为 ${10} !&quot;    echo &quot;第十一个参数为 ${11} !&quot;    echo &quot;参数总数有 $# 个!&quot;    echo &quot;作为一个字符串输出所有参数 $* !&quot;}funWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre><p>结果：</p><pre><code>第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</code></pre><h2 id="10-输入输出"><a href="#10-输入输出" class="headerlink" title="10. 输入输出"></a>10. 输入输出</h2><pre><code class="bash">#!/bin/bashwho &gt; today.log # 执行结果覆盖到文件 today.logecho &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; today.log # 执行结果追加到文件 today.logwc -l &lt; today.log # 统计 today.log 行数wc -l &lt;&lt; EOF    李白    苏轼    王勃EOF</code></pre><h2 id="11-文件包含"><a href="#11-文件包含" class="headerlink" title="11. 文件包含"></a>11. 文件包含</h2><p>test1.sh</p><pre><code class="bash">#!/bin/bashname=&quot;Chris&quot;</code></pre><p>test2.sh</p><pre><code class="bash">#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho $name</code></pre><blockquote><p>注：被包含的文件 test1.sh 不需要可执行权限。</p></blockquote><h2 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h2><p>[1] <a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-shell.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
